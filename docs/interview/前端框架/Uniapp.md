# Vue

## 一. Vue API

### 01-组件通信方式

1. 思路分析
   1. 总述知道的所有方式
   2. 按组件关系阐述使用场景
2. 回答范例
   1. 组件间的通信方式分为四类：
      1. 父子组件之间的通信：
         1. props
         2. $emit/$on
         3. ref
         4. v-model
         5. sync
      2. 兄弟组件之间的通信：
         1. eventbus
         2. $parent/$on
      3. 祖先后代之间的通信：
         1. $attrs/$listeners
         2. provide/inject
         3. $root
      4. 复杂关系之间的通信
         1. vuex

### 02-v-if和v-for优先级

1. 思路分析

   1. 给出结论
   2. 为什么
   3. 怎样解决

2. 回答范例
   1. vue2中v-for的优先级高于v-if，vue3中则相反
   2. 文档中指出，同时使用v-if和v-for是不推荐的，在vue3中，因为v-if的优先级高于v-for，因此当它们处于同一元素上时，若判断条件为循环声明的变量，则会出现未找到该变量的异常
   3. 解决：
      1. 为了过滤列表中项目：v-for="user in users" v-if="user.isActive"，此时定义一个计算属性，让其返回过滤 后的列表即可
      2. 为了避免渲染本应该被隐藏的列表：v-for="user in users" v-if="shouldShowUsers"，此时把v-if移动至容器元素上即可

### 03-vue的生命周期

3. 概述

   1. 每个vue组件实例被创建后都会经过一系列初始化步骤，比如，它需要数据观测、模板编译、挂载实例到dom、以及数据变化时更新dom。这个过程中会运行叫做生命周期钩子的函数，以便用户在特定阶段有机会添加代码
   2. vue生命周期总共可以分为8个阶段：创建前后、挂载前后、更新前后、销毁前后、以及一些特殊场景的生命周期。vue中新增了三个用于调试和服务端渲染场景

2. 生命周期钩子函数

   1. 特殊场景钩子函数

      ![image-20221013114029118](C:\Users\75560\AppData\Roaming\Typora\typora-user-images\image-20221013114029118.png)

3. 常用生命周期钩子函数的作用
   1. beforeCreate：通常用于插件开发中执行一些初始化任务
   2. created：组件初始化完毕，可以访问各种数据，获取接口数据等
   3. mounted：dom已创建，可用于访问数据和获取dom元素；访问子组件；开启定时器和消息订阅等
   4. beforeunmounted：实例被销毁前调用，可用于一些定时器和订阅的取消
4. 可能追问
   1. setup和created谁先执行
      1. setup先执行
   2. setup中为什么没有beforeCreate和created
      1. 因为setup优先执行，所以可以直接写在setup中，此时实例已经创建

### 04-v-model双向绑定原理

1. 思路分析

   1. 给出双绑定义
   2. 双绑的好处
   3. 在那使用双绑
   4. 使用方式、使用细节、vue3变化
   5. 原理实现描述

2. 回答实例

   1. 定义

      1. vue中双向绑定是一个指令‘v-model',可以绑定一个响应式数据到视图，同时视图中的变化能改变该值

   2. 好处

      1. v-model是一个语法糖，默认情况下相当于:value和@input。使用v-model可以减少大量繁琐的事件处理代码，提高开发效率

   3. 使用地方

      1. 通常在表单项上使用v-model,还可以在自定义组件上使用，表示某个值的输入和输出控制

      2. 也可用在自定义组件上

         ```js
         //用于表单上
             <input
               :value="searchText"
               @input="searchText = $event.target.value"
             />
         //用于自定义组件上
             <CustomInput
               :modelValue="searchText"
               @update:modelValue="newValue => searchText = newValue"
             />
         
         ```

   4. 使用细节

      1. 可以使用修饰符lazy、number、trim对v-model的行为做进一步限定
      2. 在vue3中，类似于sync修饰符，最终展开结果为modelValue属性和update:modelValue事件

   5. 原理

      1. 原理是value属性的绑定和一个事件的侦听
      2. 文本类型：绑定value，并侦听input事件
      3. 单选/复选：绑定checked，并侦听change事件
      4. 选择器：绑定value，并侦听change事件

### 05-nextTick的作用及实现原理

1. 思路分析
   1. nextTick是什么
   2. 为什么需要nextTick，异步更新队列实现原理解释
   3. 在什么地方使用nextTick
   4. 如何使用nextTick
   5. 源码原理
2. 回答范例
   1. 官方定义：在下次DOM更新循环结束之后执行的回调。在修改数据之后立即使用这个方法，获取最新DOM；nextTick是Vue提供的一个全局api，由于vue的异步更新策略导致我们对数据的修改不会立即体现在dom变化上，此时如果想获取最新的dom状态，就需要使用这个方法
   2. vue在更新DOM时是异步执行的。只要侦听到数据变化，vue将开启一个队列，并缓冲在同一事件循环中所发生的所有数据变更，视图中需要等队列中所有数据变化完成之后，再统一进行更新。
   3. 所以当我们想要在修改数据之后立即看到dom执行结果就需要用到nextTick方法
   4. 在nextTick方法中传入一个回调函数，在这个回调函数里进行dom操作即可
   5. 源码原理：
      1. 把回调函数放入callbacks等待执行
      2. 将执行函数放到微任务或者宏任务中
      3. 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调
   6. 案例
      1. 双击编辑一条数据并自动聚焦，自动聚焦这个dom操作就需要使用nextTick

### 06-watch和computed的区别

1. 思路分析
   1. 先看两者定义，列举使用上的差异
   2. 列举使用场景上的差异，如何选择
   3. 使用细节、注意事项
   4. vue3变化
2. 回答范例
   1. 定义
      1. 计算属性：计算属性可以从组件数据派生出新数据，最常见的使用方式是设置一个函数，返回计算之后的结果。依赖其他属性值，并且computed的值有缓存，只有它依赖的属性值变化，下一次获取computed的值时才会重新计算
      2. 监视属性：监视属性可以监测某个响应式数据的变化并执行副作用，常见用法是传递一个函数，执行副作用，没有返回值，但可以执行异步操作等复杂逻辑。每当监听的数据变化都会执行回调
   2. 使用场景
      1. 当我们需要进行数值计算，并且依赖于其他数据时，使用computed，因为可以利用computed的缓存特性，避免每次获取值的时候，都要重新计算
      2. 当我们需要在数据变化时执行异步或开销较大的操作时，使用watch，执行异步操作得到最终结果之前，设置中间状态。

### 07-子组件和父组件创建挂载的顺序

1. 思路分析
   1. 给出结论
   2. 阐述理由
2. 回答范例
   1. 创建过程自上而下先创建父组件，挂载过程自下而上先挂载子组件
   2. vue的创建过程是一个递归过程，先创建父组件，有子组件就会创建子组件，因此先创建父组件再创建子组件；子组件首次创建的时候会添加mounted钩子到队列，子组件的mounted钩子是先进入队列的，因此在patch结束后也会先执行

### 08-怎样缓存当前组件，如何更新

1. 思路分析

   1. 缓存用keep-alive，它的作用与用法
   2. 使用细节，指定/排除组件、结合router使用
   3. 使用场景
   4. 组件缓存后更新可以利用activated和beforeRouteEnter
   5. 原理阐述

2. 回答范例

   1. 缓存组件使用keep-alive组件，keep-alive是vue内置组件。使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们，这样在组件的切换过程中将状态保留在内存中，防止重复渲染DOM

   2. 使用细节：

      1. 结合include和exclude可以明确指定缓存哪些组件或排除哪些组件(字符串或正则)。vue3中结合vue-router使用时，需要反过来用router-link包裹keep-alive
      2. 设置了keep-alive组件，会多出activated和deactivated两个生命周期钩子。首次进入组件时，activated钩子在mounted之后，再次进入时没有创建前后、挂载前后的钩子了

   3. 使用场景

      1. 当不需要让页面重新加载时使用

      2. 在路由meta配置keepAlive为true或false，使用：

         ```js
         <div id="app" class='wrapper'>
             <keep-alive>
                 <!-- 需要缓存的视图组件 --> 
                 <router-view v-if="$route.meta.keepAlive"></router-view>
              </keep-alive>
               <!-- 不需要缓存的视图组件 -->
              <router-view v-if="!$route.meta.keepAlive"></router-view>
         </div>
         ```

   4. 缓存后想要获取数据，可以在beforeRouteEnter或activated中重新获取数据

   5. keep-alive内部定义了一个map，缓存创建过的组件实例。keep-alive返回的渲染函数内部会查找内嵌的组件对应的VNode，如果map中存在就直接返回它。

### 09-自定义指令

1. 思路分析

   1. 定义
   2. 何时用
   3. 如何用
   4. 常用指令
   5. vue3变化

2. 回答范例

   1. vue中提供了为数据驱动视图更加方便的操作，成为指令系统。以v-开头的行内属性都是指令，可以通过不同指令实现不同的功能，也可以自定义指令来扩展vue能力

   2. 自定义指令主要完成一些可复用低层级DOM操作

   3. 自定义指令分为定义、注册、使用三步：

      1. 定义：定义时有两种方式对象式和函数式，前者类似于组件定义，有各种生命周期，后者只会在mounted和update时执行
      2. 注册：注册时类似于组件，可以使用app.directive()全局注册，也可以使用directive局部注册
      3. 使用：使用时在注册名称前加上v-即可

   4. 常用的一些自定义指令：

      1. 防抖：v-throttle

         ```js
         // 1.设置v-throttle自定义指令
         Vue.directive('throttle', {
           bind: (el, binding) => {
             let throttleTime = binding.value; // 防抖时间
             if (!throttleTime) { // 用户若不设置防抖时间，则默认2s
               throttleTime = 2000;
             }
             let cbFun;
             el.addEventListener('click', event => {
               if (!cbFun) { // 第一次执行
                 cbFun = setTimeout(() => {
                   cbFun = null;
                 }, throttleTime);
               } else {
                 event && event.stopImmediatePropagation();
               }
             }, true);
           },
         });
         // 2.为button标签设置v-throttle自定义指令
         <button @click="sayHello" v-throttle>提交</button>
         ```

      2. 图片懒加载：v-lazy

      3. 一键复制：v-copy

   5. vue3中指令定义发生了比较大的变化，主要是钩子的名称保持和组件一致，容易记忆；可以在setup中以一个小写v开头定义自定义指令，更加方便

### 10-$attrs和$listeners的使用场景

1. 思路分析
   1. 作用，使用场景分析
   2. 使用方式和细节
   3. vue3变化
2. 回答范例
   1. 用于爷孙组件通信
   2. 通过v-bind="$attrs"和v-on="$listeners"传递属性和方法
   3. vue3中取消了$listeners，合并到了$attrs中

### 11-v-once的使用场景

1. 思路分析
   1. v-once是什么
   2. 什么时候使用
   3. 扩展：v-memo
   4. 原理
2. 回答范例
   1. v-once是vue的内置指令，作用是仅渲染指定组件或元素一次，并跳过未来的更新
   2. 当一些元素或组件在初始化渲染之后不再需要变化，可以使用v-once，是一种代码优化手段
   3. vue3.2之后新增v-memo指令，可以有条件缓存部分模板并控制其更新
   4. 编译器发现元素上有v-once时，会将首次计算结果存入缓存，再次渲染时会从缓存获取
   5. 与keep-alive的区别：
      1. keep-alive是一个组件，v-once是一个指令
      2. keep-alive是用于动态组件，在切换组件时缓存，不会调用destroy钩子，从而不会销毁组件
      3. keep-alive解决的是页面跳转时的缓存问题，v-once解决页面渲染的缓存问题

### 12-什么是递归组件

1. 思路分析
   1. 定义
   2. 使用场景
   3. 使用细节
   4. 原理
2. 回答范例
   1.  如果某个组件通过组件名称引用自己，这种情况就是递归组件
   2. 实际开发中Tree或Menu这类树形结构的组件，它们的节点往往包含着子节点，子节点的结构和父节点是相同的。这种场景适用于递归组件。
   3. 使用递归组件时，由于不能在组件内部导入自己，所以需要设置name属性，用来查找组件定义。组件内部也要有递归结束条件。

### 13-什么是异步组件

1. 思路分析
   1. 异步组件的作用
   2. 何时使用异步组件
   3. 使用细节
   4. 和路由懒加载的不同
2. 回答范例
   1. 在大型应用中，需要分割应用为更小的块，并且在需要组件时再加载它们
   2. 我们不仅可以在路由切换时使用路由懒加载，还可以在页面中使用异步组件，从而实现更细的分割粒度
   3. 使用异步组件最简单的方式是使用defineAsyncComponent指定一个load函数，结合ES模块动态导入函数可以快速实现。在Vue3中可以结合Suspense组件使用异步组件
   4. 异步组件不能被用于定义懒加载路由上，处理它的是vue框架，处理路由组件加载的是vue-router。可以在懒加载的路由组件中使用异步组件

## 二. Vue3

### 01-vue3新特性

1. api层面：Composition API、SFC Composition API语法糖，删除了filter、EventBus等
2. 框架层面：
   1. 更快：虚拟DOM编写；编译器优化：基于Proxy的响应式系统
   2. 更小：更好的摇树优化
   3. 更容易维护：TS+模块化
   4. 更容易扩展：独立的响应化模块；自定义渲染器

### 02-ref和reactive异同

1. 思路分析
   1. 两者概念
   2. 两者使用场景
   3. 两者异同
   4. 使用细节
   5. 原理
2. 回答范例
   1. ref接收内部值返回响应式Ref对象，reactive返回响应式代理对象
   2. 从定义上看ref通常用于处理单值的响应式，reactive用于处理对象类型的数据响应式
   3. 两者均是用于构造响应式数据，但是ref主要解决原始值的响应式问题
   4. 使用细节：
      1. ref返回的响应式数据在JS中使用需要加上.value才能访问其值，在视图中使用会自动脱ref，不需要.value；
      2. ref可以接收对象或数组等非原始值，但内部依然是reactive实现响应式；
      3. reactive内部如果接收ref对象会自动脱ref；
      4. 使用展开运算符展开reactive返回的响应式对象会使其失去响应性，可以结合toRefs()将值转换为ref对象之后再展开
   5. reactive内部使用Proxy代理传入对象并拦截该对象各种操作，从而实现响应式。ref内部封装一个refImpl类，并设置get value/set value，拦截用户对值的访问，从而实现响应式

### 03-watch和watchEffect异同

1.  思路分析
   1. 两者定义
   2. 使用场景
   3. 使用方式和细节
   4. 原理阐述
2. 回答范例
   1. 定义
      1. watchEffect立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数。
      2. watch监测一个或多个响应式数据并在其变化的时候调用一个回调函数
   2. 使用场景
      1. watchEffect是一种特殊watch，传入的函数既是依赖手机的数据，也是回调函数。如果不关心响应式数据变化前后的值，知实想用这些数据做些事情，那么watchEffect就是我们需要的。
      2. watch可以接收多种数据源，包括用于依赖收集的getter函数，因此它完全可以实现watchEffect的功能，同时由于可以指定getter函数，依赖可以控制的更精确，还可以获取数据变化前后的值
   3. 使用细节
      1. watchEffect在使用时，传入的函数会立即执行一次
      2. watch默认情况下不会执行回调函数，除非手动设置immediate选项
   4. 从实现上说：watchEffect(fn)相当于watch(fn,fn,{immediate:true})

### 04-vue3设计目标，做了哪些优化

1. 思路分析
   1. 总述和性能相关的新特性
   2. 逐个说细节
   3. 原理
2. 回答范例
   1. 设计目标：更小更快更友好
      1. 更小：移除了一些不常用的API
      2. 更快：diff算法优化、静态提升、事件监听缓存、SSR优化
      3. 更友好：组合式API的提出，大大增加了代码的逻辑组织和代码复用能力
   2. 优化方案
      1. 源码
         1. vue3是基于ts编写的，提供了更好的类型检查，能支持复杂的类型推导
      2. 性能
         1. 体积优化
         2. 编译优化
         3. 数据劫持优化

### 05-options API和composition API

1. 思路分析
   1. 总述不同点
   2. 开发动机
   3. 如何选择
2. 回答范例
   1. composition API是一组API，包括：reactivity API、生命周期钩子、依赖注入，使用户可以通过导入函数方式编写vue组件。而options API则通过声明组件选项的对象形式编写组件
   2. 优点
      1. composition API主要作用是能够简洁、高效复用逻辑。解决了过去options API中mixins的各种缺点，如：命名冲突等。
      2. composition API具有更敏捷的代码组织能力，可以将功能相同的代码编写在一块
      3. composition API拥有更好的类型推断，对ts支持更加友好
   3. 在中低复杂度的项目中，options API仍是一个很好的选择，对于大型，高扩展、强维护的项目，composition API会获得更大收益

## 三. vue全家桶

### 01-如何实现路由懒加载

1. 思路分析
   1. 必要性
   2. 何时用
   3. 怎么用
   4. 使用细节
2. 回答范例
   1. 当打包构建时，js包会非常大，影响页面加载，利用路由懒加载我们可以把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件，这样会更加高效，是一种优化手段
   2. 一般来说，对所有的路由都是用动态导入是一个好主意
   3. 给component选项设置一个返回Promise组件的函数就可以定义懒加载路由
   4. 路由中不能使用异步组件，但组件中可以使用异步组件

### 02-router-link和router-view

1. 思路分析
   1. 总述两者作用
   2. 阐述整体流程
   3. 分析两个组件实现方式
2. 回答范例
   1. vue-router中两个重要组件router-link和router-view，分别起到路由导航和组件内容渲染作用
   2. vue-router会监听popstate事件，点击router-link之后页面不会刷新，而是拿出当前path去和routes中path匹配，获得匹配组件之后，router-view会将匹配组件渲染出来
   3. router-link默认会生成a标签，点击后取消默认跳转行为而是执行一个navigate方法，它会pushState以激活事件处理函数，重新匹配一个路由injectedRoute，router-view的渲染函数依赖这个路由，根据该路由获取要渲染的组件并重新渲染

### 03-history模式和hash模式

1. 思路分析
   1. 总述两者区别
   2. 阐述使用细节
   3. 实现方式
2. 回答范例
   1. vue-router有3个模式，其中history和hash模式更为常用，两者差别在于显示形式和部署上
   2. 使用说明：
      1. hash：使用hash值来作为路由，支持所有浏览器，使用和部署都比较简单
      2. history：url看起来更优雅美观，依赖于HTML5 History API和服务器配置，部署时需要做特殊配置：web服务器需要做回退处理，否则会出现刷新页面404问题
   3. 在实现上不管哪种模式，最终都是通过监听popstate事件触发路由跳转处理

## 四. 综合应用

### 01-Vue中如何扩展一个组件

1. 思路分析
   1. 按照逻辑扩展和内容扩展来列举
      1. 逻辑扩展：mixin、extends、composition API
      2. 内容扩展：slots
   2. 分别说出他们使用方法、场景差异和问题
   3. 作为扩展，可以说出vue3中新引入的composition API带来的变化
2. 回答范例
   1. 常见的组件扩展方法有：mixins、extends、slots
   2. 混入mixins是分发vue组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件options，所有混入对象的options将被混入该组件本身的options
   3. 插槽主要用于vue组件中内容的分发，可以用于组件扩展
   4. extends不太常用，只能用于扩展单个对象，但其与mixins发生冲突时，优先级更高
   5. 混入的数据和方法不能明确判断来源且有可能和当前组件的变量产生命名冲突，vue3中的组合式API可以解决这些问题，利用独立出来的响应式模块可以很方便的编写独立逻辑并提供响应式数据，然后在setup中组合使用

### 02-子组件能否修改父组件的数据

1. 简述
   1. 可以直接修改，但是组件化开发过程中有个单向数据流原则，不在子组件中修改父组件的值是个常识问题
2. 思路分析
   1. 讲讲单向数据流原则，表明为什么不能这样做
   2. 举几个常见场景例子说说解决方案
   3. 结合实践讲讲需要修改父组件状态应该如何做
3. 回答范例
   1. 所有prop使得其父子之间形成了一个单项下行绑定：
      1. 父组件prop的更新会向下流动到子组件中，但反过来则不行。这样会防止从子组件意外变更父组件的状态，从而导致应用的数据流向难以理解。
      2. 此外，父组件prop发生变更时，子组件的prop都会刷新变更为最新值。这样就会导致一个子组件变更而引起所有组件更新。此时，控制台会发出警告。
   2. 实际开发中有两个场景会想要修改prop
      1. 这个prop用来传递一个初始值，这个子组件希望将其作为一个本地的数据使用。在这种情况下，最好定义一个本地的data，并将传递过来的prop作为其初始值
      2. 这个prop传递过来但是需要转换。在这种情况下，最好使用这个prop的值定义一个计算属性
   3. 实践中如果确实想要改变父组件的属性应该用自定义事件来去做这个变更。
   4. 注意：虽然我们不能直接修改一个传入的对象或数组类型的prop，但是我们可以修改其内嵌的对象或属性

### 03-vue权限管理如何做

1. 思路分析
   1. 权限管理需求分析：菜单权限、路由权限、按钮权限、接口权限
   2. 权限管理的实现方案：分前端方案和后端方案阐述
   3. 说说各自的优缺点
2. 回答范例
   1. 菜单权限
      1. 前端方案：把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表，最后通过addRoute添加动态路由
      2. 后端方案：把所有路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过addRoute动态添加
   2. 按钮权限：---

### 04-你总结的vue最佳实践有哪些

1. 思路分析
   1. 编码风格
   2. 性能
   3. 安全
2. 回答范例
   1. 编码风格方面：
      1. 命名组件使用多词避免与HTML元素冲突
      2. 使用细节化方式定义属性而不是只有一个属性名
      3. 属性名声明时使用驼峰命名
   2. 性能方面：
      1. 路由懒加载减少应用体积
      2. 利用SSR减少首屏加载时间
      3. 利用v-once渲染不需要更新的内容
      4. 一些长列表利用虚拟滚动技术避免内存过度占用
      5. 对于深层嵌套对象的大数组可以使用shallowRef或shallowReactive降低开销
   3. 安全方面：
      1. 不使用不可信模板，例如使用用户输入拼接模板：`template:  + userProvidedString + `
      2. 小心使用v-html，:url，:style等，避免html、url、样式等注入

### 05-你知道的vue性能优化

1. 路由懒加载：有效拆分App尺寸，访问时才异步加载
2. keep-alive缓存：避免重复创建组件实例，且能保留缓存组件状态
3. v-once：不再变化的数据使用v-once
4. v-memo：按条件跳过更新
5. 长列表性能优化：虚拟滚动，之渲染少部分区域的内容
6. 事件的销毁：vue组件销毁时，自动解绑它的全部指令及事件监听器
7. 图片懒加载：v-lazy
8. 按需引入第三方组件库
9. 服务端渲染/静态网站生成：SSR/SSG

### 06-SPA、SSR

1. 思路分析
   1. 两者概念
   2. 两者优缺点
   3. 使用场景
   4. 其他选择
2. 回答范例
   1. SPA即单页面应用。一般也称为客户端渲染CSR；MPA即多页面应用。一般也称为服务端渲染SSR
   2. 优缺点
      1. SPA只会首次请求html文件，后续只需要请求JSON数据即可，因此用户体验更好，节约流量，服务端压力也小。但是首屏加载时间会变长，对SEO不友好
      2. MPA由于HTML内容在服务器一次性生成出来，首屏加载快，搜索引擎也可以很方便的抓取页面信息。但是有性能，开发受限等问题
   3. 对首屏加载优化、SEO有需求时，就可以考虑SSR
   4. 对于一些不常变化的静态网站，可以考虑使用预渲染方案

## 五. 原理源码

### 01-对数据响应式的理解

1. 思路分析
   1. 什么是响应式
   2. 为什么vue需要响应式
   3. 它给我们带来了什么好处
   4. vue中的响应式是如何实现的，有哪些优缺点
   5. vue3中响应式的新变化
2. 回答范例
   1. 数据响应式就是能够使数据变化可以被监测并对这种变化做出响应的机制
   2. mvvm框架中要解决的一个核心问题就是连接数据层和视图层，通过数据驱动视图更新
   3. 通过数据响应式加上虚拟DOM和patch算法，可以做到只操作数据，而不用去接触繁琐的dom操作，从而大大提高了开发效率，降低开发难度
   4. vue2中的数据响应式会根据数据类型做不同的处理：
      1. 如果是对象类型，则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或者发生变化时，会被监测到并做出响应。
      2. 如果是数组类型，则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而做出响应。
      3. 缺点：新增或删除属性时，需要使用Vue.set/delete这种特殊的api，对Map、Set数据结构不支持，直接通过下标修改数组页面不会变化。
   5. vue3中的数据响应式：
      1. 利用ES6的Proxy代理要响应的数据，不需要再使用特殊的api，初始化性能和内存消耗都得到改善。
      2. Proxy相比于defineProperty的get、set方法新增了delete方法，并且set方法可以完成对添加属性的监测，从而解决了vue2响应式不能直接添加和删除属性的缺点。
      3. Proxy可以直接监听对象而非属性，可以直接监听数组的变化

### 02-对虚拟DOM的理解

1. 思路分析
   1. vdom是什么
   2. 引入vdom的好处
   3. vdom如何生成，又如何成为dom
   4. 在后续diff中的作用
2. 回答范例
   1. 虚拟dom就是虚拟的dom对象，本身就是一个JavaScript对象，通过一个不同的属性描述一个视图结构
   2. 好处：
      1. 将真实元素节点抽象为VNode，有效减少操作dom次数，从而提高程序性能：
         1. 直接操作dom元素是有限制的，比如diff、clone等操作，一个真实dom有许多内容，如果直接对其进行diff操作，会额外的diff一些没有用的内容，clone时也是会将其全部内容复制。
         2. 频繁的操作dom容易引起页面的重绘和回流，但是通过VNode进行中间处理，可以有效减少直接操作dom的次数，从而减少页面的重绘和回流
      2. 方便实现跨平台
         1. 同一VNode节点可以渲染成不同平台上的对应内容，比如：在浏览器中是dom元素，在Native是对应的控件
   3. 在vue中我们编写的template模板会被编译器compiler编译为渲染函数，在mount挂载的时候会调用render函数，返回的对象就是虚拟DOM，然后再通过patch进一步转化为真实DOM。
   4. 挂载结束后会进入更新流程，如果某些响应式数据发生变化，将会引起组件重新render，此时就会生成新的虚拟DOM，和上一次的渲染结果diff就得到变化的地方，从而转换为最小量的dom操作，高效更新视图

### 03-对diff算法的了解

1. 思路分析
   1. diff算法是干什么的
   2. 它的必要性
   3. 它何时执行
   4. 具体执行方式
   5. 拔高：vue3中的优化
2. 回答范例
   1. vue中的diff算法称为patching算法，虚拟DOM转化为真实DOM就需要通过patch方法转换
   2. vue2中通过diff算法可以更精准的找到发生变化的地方并高效更新
   3. vue中diff算法执行时刻是组件内的响应式数据变更触发实例执行其更新函数，更新函数会再次执行render函数获得最新的虚拟DOM，然后执行其patch函数，并传入新旧两次虚拟DOM，通过比对找到变化的地方，最后将其转化为对应的DOM操作。
   4. patch过程其实是一个递归过程，遵循深度优先、同层比较的策略：
      1. 没有新节点，直接触发旧节点的destroy钩子
      2. 没有旧节点，说明是页面初始化的时候，不需要比较，直接调用createElm全部新建
      3. 通过isSameVnode判断两个节点是否是同类节点，不同则删除重新创建
      4. 如果是同类节点，则调用patchNode处理这两个节点：
         1. 如果双方都是文本节点，则更新文本内容
         2. 如果都是元素节点，则递归更新子元素，同时更新元素属性
            1. 如果新节点没有子节点，则删除旧的
            2. 如果旧节点没有子节点，则添加新的
            3. 如果都有子节点，则调用updateChildren函数比较子节点，根据情况选择调用patchNode再次进行patch流程，或调用createElm创建新节点
   5. 比较新旧节点：
      1. 同层级比较，循环从两边向中间收拢
      2. 按索引分为oldStartIndex、oldEndIndex和newStartIndex和newEndIndex
      3. 四个索引代表的节点两两进行比较
         1. 有相同的节点则复用旧节点作为真实节点。所处开始索引向后移动一位，结束索引向前移动一位
         2. 皆不相同则创建新节点作为真实节点，新节点的开始索引向后移动一位
         3. 退出循环
            1. 新节点的开始索引大于结束索引，删除旧节点开始索引和结束索引之间的所有节点
            2. 旧节点的开始索引大于结束索引，创建新节点开始索引和结束索引之间的所有节点

### 04-key的作用

1. 思路分析
   1. 给出结论：key的作用是用于优化patch性能
   2. key的必要性
   3. 实际使用方式
   4. 总结：从源码层面描述一下vue如何判断两个节点是否相同
2. 回答范例
   1. key的作用主要是为了更高效的更新虚拟DOM，key是每个VNode的唯一id，根据key，可以更准确、更快速的找到这个VNode
   2. vue在patch过程中判断两个节点是否是相同节点key是一个必要条件，如果不定义key值的话，key默认为undefined，此时vue会默认认为比较的两个节点是同一个，哪怕实际上不是，这就导致了频繁更新元素，使得patch过程比较低效
   3. 使用index作为key值：
      1. 性能消耗：当我们在前方加入或者删除一条数据的时候，index顺序就会被打乱，导致新节点的key值改变，从而导致页面上的数据被重新渲染。
      2. 数据错位：如果结构中包括输入类的DOM，会产生错误的dom更新

### 05-从template到render的处理过程

1. 思路分析
   1. 引入vue编译器概念
   2. 说明编译器的必要性
   3. 阐述编译器工作流程
2. 回答范例
   1. vue有个独特的编译器模块，成为compiler，它的主要作用是将用户编写的template模板编译为js中可执行的render函数
   2. 这个编译过程是为了方便前端程序员能高效的编写视图模板。
   3. vue中编译器会先对template进行解析，这一步成为parse，结束之后会得到一个js对象，我们称为抽象语法树AST，然后是对AST进行深加工的转换过程，这一步称为transform，最后将前面的到的AST生成为js代码，也就是render函数

### 06-vue实例挂载过程中发生了什么

1. 思路分析
   1. 初始化
   2. 建立更新机制
2. 回答范例
   1. 挂载的过程是一个初始化的过程，整体上做了两件事：初始化和建立更新机制
   2. 初始化会创建组件实例，初始化组件状态，创建各种响应式数据
   3. 建立更新机制这一步会立即执行一次更新函数，这会首次执行组件的渲染函数并执行patch将虚拟DOM转化为真实DOM；同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，使得以后响应式数据变化的时候会执行对应的更新函数

### 07-vue-loader是什么，有什么作用

1. 思路分析
   1. vue-loader是什么
   2. vue-loader有什么用
   3. vue-loader何时生效
   4. vue-loader如何工作
2. 回答范例
   1. vue-loader是用于处理单文件组件的webpack loader
   2. 因为有了vue-loader我们可以在项目中编写SFC格式的vue组件，可以把代码分割为script、style
   3. webpack打包时，会以loader的方式调用vue-loader
   4. vue-loader被执行时，它会对SFC中的每个语言块用单独的loader链处理。最后将这些块装配成最终的组件模块