# 浏览器

## 01-本地存储

1. 共同点：都是保存在浏览器端且同源的
2. 区别：
   - 存储大小：cookie数据大小不能超过4k，sessionStorage和localStorage可以达到5M或更大
   - 有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除；cookie在设置的cookie过期时间之前一直有效
   - 数据与服务器之间的交互方式：cookie的数据会自动地传递到服务器，服务器端也可以写cookie到客户端，sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
3. 应用场景：
   - 标记用户与跟踪用户行为的情况，推荐使用cookie
   - 适合长期保存在本地的数据，推荐使用localStorage
   - 敏感账号一次性登录，推荐适用sessionsStorage
   - 存储大量数据的情况、富文本编辑器保存的编辑历史等，推荐使用indexDB

## 02-localStorage的限制

1. 浏览器大小不同意，并且在IE8以上的版本才支持localStorage
2. 浏览器会把localStorage的值类型限定为string类型，与常用的JSON对象需要做转换
3. localStorage在浏览器的隐私模式下是不可读取的
4. localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
5. localStorage不能被爬虫抓取

## 03-浏览器输入URL之后发生了什么

1. URL解析
2. DNS查询
3. TCP连接
4. 处理请求
5. 接收响应
6. 渲染页面

## 04-浏览器如何渲染页面的

1. HTML被HTML解析器解析为DOM树
2. CSS被CSS解析器解析为CSSOM树
3. 结合DOM树和CSSOM树，生成一颗渲染树，这一过程被称为Attachment
4. 回流：根据生成的渲染树，进行回流，得到节点的几何信息（位置、大小）
5. 重绘：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
6. 将像素发送给GPU，展示在页面上

## 05-怎样理解重绘和回流

1. 概念
   - 回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置
   - 重绘：当计算好盒子模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制
2. 触发时机
   1. 回流
      - 添加或删除可见的DOM元素
      - 元素的位置发生变化
      - 元素的尺寸发生变化
      - 内容发生变化
      - 页面一开始渲染的时候
      - 浏览器的窗口尺寸变化
      - 获取某些属性(offset相关，scroll相关，client相关，getComputedStyle())
   2. 重绘
      - 颜色的改变
      - 文本方向的改变
      - 阴影的修改
3. 优化
   1. 浏览器自己的优化
      - 浏览器会维护1个队列，把所有会引起重绘和回流的操作放入这个队列，等队列中的操作到一定数量或到了一定的时间间隔，浏览器就会清空队列，进行一批处理，这样多次的重绘和回流就变成了一次
   2. 用户所做优化
      - 不要一条一条修改DOM样式，先定义好css的class，然后修改DOM的className
      - 为动画的HTML元素，使用fixed或absolute的position
      - 避免使用table布局，table中每个元素的大小及内容的改动，都会导致table的重新计算
      - 避免使用CSS的JavaScript表达式

## 06-事件循环

1. 概念

   - JavaScript是一门单线程语言，意味着同一时间只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环
   - JavaScript中所有任务可以分为同步任务和异步任务，同步任务进入主线程，即主执行栈；异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行
   - 异步任务可以细分为宏任务和微任务，宏任务执行时机是在当前宏任务执行完成后，查看微任务的事件队列，然后将里面的所有微任务依次执行完；微任务的执行时机是在主函数执行结束之后，当前宏任务结束之前

2. 常见的宏任务与微任务

   1. 微任务
      - Promise.then()
      - MutationObserve
      - Object.observe
      - process.nextTick
   2. 宏任务
      - setTimeOut/setInterVal
      - await
      - script(外层同步代码)
      - postMessage

3. async和await

   - async用来声明一个异步方法，await用来等待异步方法执行，await阻塞后面的代码，即加入微任务队列

4. 实例分析

   ```js
   async function async1() {
       console.log('async1 start')
       await async2()
       console.log('async1 end')
   }
   async function async2() {
       console.log('async2')
   }
   console.log('script start')
   setTimeout(function () {
       console.log('settimeout')
   })
   async1()
   new Promise(function (resolve) {
       console.log('promise1')
       resolve()
   }).then(function () {
       console.log('promise2')
   })
   console.log('script end')
   
   // 结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout
   ```

## 07-垃圾回收机制

1. 概述

   - 浏览器的JavaScript具有自动垃圾回收机制，也就是说，执行环境会负责管理代码执行过程中使用的内存
   - 原理：垃圾收集器会定期找出那些不再继续使用的变量，然后释放其内存

2. 实现方式

   1. 标记清除

      - 当变量进入环境时，就将这个变量标记为“进入环境”，当变量离开环境时，被标记为”离开环境“

      - 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间

        ```js
        function test(){
        var a = 10 ;             //被标记 ，进入环境 
        var b = 20 ;             //被标记 ，进入环境
        }
        test();                  //执行完毕 之后 a、b又被标离开环境，被回收。
        ```

   2. 引用计数

      - 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1

      - 如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另一个值，则这个值引用次数减1

      - 当这个值的引用次数变为0时，就说明没办法再引用该值，因而就可以将占用的内存空间回收

        ```js
        function test(){
            var a = {} ;        //a的引用次数为0 
            var b = a ;         //a的引用次数加1，为1 
            var c =a;           //a的引用次数再加1，为2
            var b ={};          //a的引用次数减1，为1
        }
        ```

