<!-- # JavaScript

## 01-数据类型和存储上的差别

1. 数据类型
   1. 基本数据类型：Number、String、Boolean、Undefined、Null、symbol
   2. 复杂数据类型：Object、Array、Function
   3. 其他复杂数据类型：Date、RegExp、Map、Set
2. 存储区别
   1. 声明变量时不同的内存地址分配
      1. 基本数据类型存储在栈中，在栈中存放的是对应的值
      2. 引用类型的对象存储在堆中，在栈中存放的是指向堆内存的地址
   2. 不同的类型数据导致赋值变量时的不同
      1. 简单类型赋值，是生成相同的值，两个对象对应不同的地址
      2. 复杂类型赋值，是将保存对象的内存地址赋值给另一个变量。即两个变量指向堆内存中同一个对象

## 02-typeof与instanceof

1. 概述：
   1. typeof一般是用来判断变量是否存在，[返回它的类型]()，其中基本数据类型null返回的是一个object，但null不属于引用类型，typeof除了判断function函数会识别，其他的引用类型输出均为object
   2. instanceof主要用于判断一个实例是否属于某种类型，可以用来判断引用数据类型，但不能正确判断基本数据类型，根据在原型链中查找判断当前数据的原型对象是否存在[返回布尔类型]()
2. 使用
   1. typeof a !=="undefined" 判断变量a是否存在
   2. person instanceof Person 判断person实例对象是否是构造函数Person生成的对象

3. 区别
   1. typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值
   2. instanceof可以准确地判断复杂引用数据类型，但是不能正确判断基本数据类型
   3. typeof也有弊端，可以判断除null之外的基本数据类型，但对于引用类型，除function外都无法判断
   4. 如果需要通用检测数据类型，可以采用Object.prototype.toString，调用该方法，统一返回[Object xxx]

## 03-深拷贝与浅拷贝

1. 概述
   1. 浅拷贝：拷贝基本数据类型为它的值，拷贝引用数据类型为地址，生成新的数据，修改新的数据会影响原数据，实际开发常用的方法有Object.assign，扩展运算符，slice()，concat()
   2. 深拷贝：在内存中开辟一个新的栈空间保存新的数据，修改新数据不会影响到原数据，开发中常用的方法有loadsh中的_.cloneDeep()方法，JSON.stringify()（该方法会忽略函数、undefined、symbol）
2. 浅拷贝
   1. 指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝
   2. 如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址
3. 深拷贝
   1. 深拷贝开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性
4. 区别
   1. 浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响到原对象
   2. 深拷贝会另外创造一个一摸一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象

## 04-作用域链

1. 概述
   1. 作用域可以理解为函数或变量的生效范围，作用域决定了代码区块中变量和其他资源的可见性
   2. 作用域可分为：全局作用域、函数作用域、块级作用域
   3. js中访问一个变量，会在当前作用域进行查找，访问不到，会逐级向上查找，查找的过程被称为作用域链
2. 作用域
   1. 全局作用域
      1. 任何不在函数中或是大括号中声明的变量，都是在全局作用域下，在程序中的任何位置都可以访问
   2. 函数作用域
      1. 也称为局部作用域，声明在某个函数内部，只能在函数中访问，不能在函数以外访问
   3. 块级作用域
      1. 在大括号中，使用let和const声明的变量存在于块级作用域，大括号之外不能访问这些变量
   4. 词法作用域
      1. 又称作静态作用域，变量被创建时就已经确定，而非执行阶段确定的
3. 作用域链
   1. 当在JavaScript中使用一个变量的时候，首先JavaScript引擎会在当前作用域下寻找该变量，如果没有找到，再到它的上层作用域寻找，以此类推直到找到该变量
   2. 如果在全局作用域下仍然找不到该变量，就会在全局范围内隐士声明该变量（非严格模式下）或直接报错

## 05-原型、原型链

1. 概述
   1. 原型是我们创建函数的时候，系统帮我们自动生成的一个对象，主要作用是解决构造函数内部方法内存资源浪费问题。
   2. 在开发中，我们一般把实例对象的一些通用方法放入原型中，在vue里也会给vue的原型添加一些公共类方法来实现所有的组件中可以共享成员
   3. 原型链是js对象的一种查找机制，遵循就近原则。当我们访问一个对象中的成员时，会优先访问自己的，如果自己没有就访问原型的，如果原型也没有，就会访问原型的原型，直到终点null，如果还没有，此时属性就会获取undefined，方法就会报错xxx is not a function

2. 原型
   1. 每个函数都有一个特殊的属性叫做—原型prototype
   2. 原型对象身上有一个自由属性constructor指向该函数
3. 原型链
   1. 原型对象也有可能拥有原型，并从中继承方法和属性，这种关系被称为原型链
   2. 在对象实例和它的构造器之间建立一个链接，之后通过上朔原型链，在构造器中找到这些属性和方法
4. 总结
   1. 一切对象都是继承自Object对象，Object对象直接继承自根源对象null
   2. 一切的函数对象，都是继承自Function对象，Object对象直接继承自Function对象
   3. Function对象的 _proto_ 会指向自己的原型对象，最终还是继承自Object对象

## 06-闭包

1. 概述
   1. 闭包是一个可以访问其他函数内部变量的函数，主要作用是解决变量污染问题，也可以用来延长局部变量的生命周期。
   2. 闭包几乎是无处不在的，大多数情况下，在回调函数中闭包是用的最多的
2. 闭包是什么
   1. 一个函数被应用包围，这样的组合就是闭包
   2. 每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接的桥梁
3. 使用场景
   1. 创建私有变量
   2. 延长变量的生命周期
4. 注意事项
   1. 如果不是特定任务使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响

## 07-内存泄露

1. 概述
   1. 内存泄漏一般是指变量的内存没有及时回收，导致内存资源浪费
      1. 意外的全局变量
      2. 闭包
      3. 未被清空的定时器
      4. 未被销毁的事件监听
      5. DOM引用
2. 内存泄漏是什么
   1. 内存泄漏是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存
   2. 大多数语言提供自动内存管理，称为“垃圾回收机制”
3. 垃圾回收机制
   1. 概念：JavaScript具有自动垃圾回收机制，执行环境会负责管理代码执行过程中使用的内存
   2. 原理：垃圾收集器会定期找出哪些不在继续使用的变量，然后释放其内存
   3. 实现方式：标记清除、引用计数
      1. 标记清除
         1. 当变量进入执行环境时，就标记这个标量为“进入环境“，进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为”离开环境“
         2. 垃圾回收程序运行时，会标记内存中存储的所有变量
      2. 引用计数

## 08-数组中的常用方法

1. 遍历方法
   1. map：映射数组，得到一个映射之后的新数组
   2. filter：筛选数组，返回一个新数组
   3. forEach：遍历数组，操作会[影响原数组]()
   4. some：判断数组中是否有元素满足条件，返回布尔值
   5. every：判断数组中所有元素是否满足条件，返回布尔值
   6. findIndex：查找元素下标
   7. reduce：给数组每一个元素执行一次回调，已包含用于数组求和
2. 操作方法
   1. push：末尾新增元素，返回值是新数组的长度
   2. unshift：开头新增元素，返回值是新数组的长度
   3. pop：末尾删除元素，返回值是删除的末尾元素
   4. shift：开头删除元素，返回值是删除的开头元素
   5. splice：删除指定下标元素，start，deleteCount，...item
3. 其他方法
   1. reverse：反转数组，会修改原数组
   2. sort：数组排序，会修改原数组
   3. join：拼接数组元素，返回值是拼接之后的字符串
   4. slice：提取数组元素，返回值是一个新数组
   5. indexOf：查询元素是否存在，返回查找到指定元素的第一个索引
   6. includes：查询元素是否存在，返回一个布尔值

## 09-字符串常用方法

1. indexOf：查询某个字符下标，一般用于判断字符串中是否包含某些字符
2. split：切割字符串，返回值是切割后的新数组
3. substring：截取字符串，返回值是截取后的新字符串
4. replace：替换字符串，返回值是替换后的新字符串
5. toLowerCase：转小写
6. toUpperCase：转大写

## 10-new操作符

1. 作用

   1. 创建一个新对象obj
   2. 将对象与构造函数通过原型链连接起来
   3. 将构造函数中的this绑定到新建的对象obj上
   4. 返回该实例对象

2. 手写new操作符

   ```js
   function mynew(Fn,...args){
   	// 1. 创建一个新对象
   	const obj = {}
   	// 2. 新对象原型指向构造函数原型对象
   	obj.__proto__ = Fn.prototype
   	// 3. 将构造函数的this指向新对象
   	let result = Fn.apply(obj,args)
   	4. 根据返回值判断
   	return result instanceof Object ? result : obj
   }
   ```

## 11-this

1. 概述
   1. 绝大多数情况下，函数的调用方式决定了this对象的指向
   2. this关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象
2. 绑定规则
   1. 默认绑定
      1. 非严格模式下，默认绑定，this指向window；严格模式下，this会绑定到undefined
   2. 隐式绑定
      1. 函数作为某个对象的方法调用，此时this就指向这个上级对象
      2. this永远指向最后调用它的对象
   3. new绑定
      1. 通过构造函数，new关键字产生的实例对象，此时this指向这个实例对象
      2. 特殊情况，如果new过程，构造函数返回一个对象，则this指向这个对象
3. 箭头函数
   1. 没有绑定自己的this，箭头函数的this指向它的上一级作用域中的this

## 12-高阶函数和柯里化

1. 高阶函数
   1. 高阶函数是一个可以接收函数作为参数，甚至返回一个函数的函数
   2. 闭包的实现与回调函数都是属于高阶函数
2. 柯里化
   1. 函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回新函数，新函数接收余下参数
   2. 函数柯里化主要作用和特点就是参数复用、提前返回、延迟执行
   3. 对于柯里化后的函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数；当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数

## 13-防抖和节流

1. 定义
   1. 防抖：n秒后再执行，若在n秒内被重复触发，则重新计时（debounce）
   2. 节流：n秒内只执行一次，若在n秒内重复触发，只有一次生效（throttled）
2. 应用场景
   1. 防抖：
      1. 搜索框输入，只需用户最后一次输入完成后，再发送请求
      
      2. 手机号、邮箱验证输入规则
      
      3. 窗口大小，等窗口调整完成后，再计算窗口大小
      
         ```js
         function debounce(callback, time) {
           // 定时器变量
           let timer = null;
           // 返回一个函数
           return function (e) {
             // 判断
             if (timer !== null) {
               clearTimeout(timer);
             }
         
             // 启动定时器
             timer = setTimeout(() => {
               callback.call(this, e);
               timer = null;
             }, time);
           };
         }
         
         ```
      
         
      
   2. 节流
   
      1. 滚动加载，加载更多，或滚动到底部监听
   
         ```js
         function throttle(callback, wait) {
           // 定义开始时间
           let start = 0;
           // 返回一个函数
           return function (e) {
             // 获取当前的时间戳
             let now = Date.now();
             // 判断
             if (now - start >= wait) {
               // 满足条件,执行回调,修改开始时间
               callback.call(this, e);
               start = now;
             }
           };
         }
         
         ```
   
         

## 14-递归

1. 概述
   1. 递归是一个函数在内部调用自己，这个函数就是递归函数
   2. 核心思想：把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题
2. 应用场景
   1. 数组求和
   2. 斐波那契数列
   3. 数组扁平化
   4. 数组对象格式化

## 15-数组去重

1. 利用Set

   ```js
   1. const result = Array.from(new Set(arr))
   2. [...new Set(arr)]
   ```

2. filter+indexOf

   ```js
   var result = arr.filter(function(item,index){
        return arr.indexOf(item) === index;  // 因为indexOf 只能查找到第一个  
   });
   ```

3. 利用Map

   ```js
   const unique4 = arr => {  
     const map = new Map();  
     const res = [];  
     for (let i = 0; i < arr.length; i++) {    
       if (!map.has(arr[i])) {      
         map.set(arr[i], true);
         res.push(arr[i]);    
       }  
     }  
     return res;
   }
   ```

   

## 16-数组扁平化

1. 概述

   1. 数组扁平化是指将一个多维数组变为一个一维数组

2. 方法

   1. 使用flat

      ```js
      const res1 = arr.flat(Infinity);
      ```

   2. 使用正则

      ```js
      const res2 = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
      ```

## 17-for of可以遍历哪些对象

1. for...of是ES6新增的一个遍历方法，但只限于迭代器（iterator），所以普通对象用for...of遍历是报错的
2. 可迭代的对象：包括Array、Map、Set、String对象等

## 18-null和undefined

1. 概述
   1. undefined表示一个变量自然的，最原始的状态
   2. null表示一个变量被人为的设置为空对象
2. 出现场景
   1. undefined
      - 声明了一个变量，但没有赋值
      - 访问对象上不存在的属性
      - 函数定义了形参，但没有传递实参
      - 使用void对表达式求值
   2. null
      - 空值
      - 栈中的变量没有志向堆中的内存对象

## 19-Set和Map的区别

1. Set
   - 成员不能重复
   - 只有键值，没有键名，有点类似数组
   - 可以遍历，方法有add、delete、has
2. Map
   - 本质上是键值对的集合，类似集合
   - 可以遍历，方法很多，可以跟各种数据格式转换

## 20-delete使用原则

1. delete能删除的
   - 可配置对象的属性
   - 隐式声明的全局变量
   - 用户定义的属性
2. delete不能删除的
   1. 显式声明的全局变量
   2. 内置对象的内置属性
   3. 一个对象从原型继承而来的属性

## 21-箭头函数

1. 基本语法
   1. 参数
      - 如果箭头函数没有参数，直接写一个空括号即可
      - 如果箭头函数参数只有一个，可以省略包裹参数的括号
      - 如果箭头函数有多个参数，将参数依次用逗号分割，包裹在括号中即可
   2. 函数体
      - 如果函数体只有一句代码，返回的是某个变量或简单js表达式，可以省略大括号
      - 如果函数体只有一句代码，返回的是一个对象，可以用小括号包裹返回的对象
      - 如果函数体只有一句代码，并且没有返回值，可以在这条语句前加一个void关键字
2. 箭头函数与普通函数的区别
   1. 语法更加简洁、清晰
   2. 箭头函数不会创建自己的this
      - 箭头函数没有自己的this，指向定义时所处的外层执行环境的this，且永远不会改变
      - call()/apply()/bind()无法改变箭头函数中this的指向
      - 箭头函数不能作为构造函数使用
      - 箭头函数没有原型prototype、

## 22-ES6新特性

1. 变量和作用域
2. 原生对象的方法扩展
   1. String
      - repeat()方法
      - 模板字符串
   2. RegExp
      - u/y/s修饰符
      - 第一个参数是正则表达式，指定第二个参数不再报错
   3. Number
      - parseInt()方法
      - 二进制八进制新写法
   4. Function
      - 函数参数默认值
      - rest参数
      - 函数内部严格模式
      - 箭头函数
   5. Array
      - 扩展运算符...
   6. Object
      - Object.is()
      - Object.assign()
      - Object.keys()
      - Object.values()
3. 数据结构Set和Map
   1. Set
      - 类似于数组的数据结构，存储的成员都是不重复的
   2. WeakSet
      - 类似于Set，区别在于成员只能是对象类型；对象都是弱引用
   3. Map
      - Map对象保存键值对，并且能够记住键的原始插入顺序
   4. WeakMap
      - 类似于Map，区别在于只接受对象作为键名；键名所指向的对象不计入垃圾回收机制
4. Proxy和Reflect
   1. Proxy
      - 对目标对象加上一层拦截，外界对对象的访问都必须通过这层拦截器，对外界的访问进行过滤和改写
   2. Reflect
      - 将Object对象上一些属于语言内部的方法放在Reflect上；修改Object对象上的某些方法的返回值，使得更加合理化
5. class、module
   1. class
      - 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用
   2. module
      - ES6模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

## 23-哪些类型可以被扩展操作符...扩展

1. 适用类型：数组、对象、字符串
   - 复杂数据类型都可以，当要转化为可迭代数据结构时可设置对象的迭代器对扩展出来的值进行操作
   - 基本数据类型只有String可以适用扩展运算符
2. 使用场景
   1. 函数调用传参时
   2. 数组里push多个元素
   3. 合并数组时
   4. 扩展运算符后面可以跟表达式

## 24-call、apply、bind的作用和区别

1. 作用
   - 都可以改变函数内部的this指向
2. 区别
   - call和apply会立即调用函数，bind不会立即执行而是生成一个修改this之后的新函数
   - call和bind是列表传参，apply是数组或伪数组传参


 -->
