# Java基础

## 01-Java基础全程学习内容

### 1.1-第一阶段

- Java概述、关键字、标识符、变量、运算符、流程控制语句、数组

### 1.2-第二阶段

- 类及类的内部成员
- 面向对象的三大特征
- 其他关键字的使用

### 1.3-第三阶段

- 异常处理、多线程、IO流、集合框架、反射、网络编程、新特性、其他常用API等

## 02-Java语言概述

### 2.1-Java程序编写和执行的过程

- 编写：将java代码编写在.java结尾的源文件中
- 编译：针对于.java的源文件进行编译操作。格式：javac 源文件名.java
- 运行：针对编译生成的字节码文件，进行解释运行。格式：java 字节码文件名

### 2.2-编写时要求

1. mian()方法的格式是固定的。表示程序的入口。格式：public static void main(String[] args){}
   - 只能变化String args[]结构，可以写成：String args[] 或 String[] a
2. Java程序是严格区分大小写的
3. 每一行执行语句必须以  ；结尾
4. 一个java文件中只能声明一个类由public修饰，且该类名必须与源文件名相同

### 2.3-编译时要求

1. 编译不通过：语法可能存在问题
2. 编译之后会生成一个或多个字节码文件，一个字节码是文件对应一个java类

4. 文档注释
   javadoc -d mydoc -author -version HelloWorld.java 生成一个html文档(介绍该类)

## 03-变量与运算符

### 3.1-标识符

- 命名规则
  - 由字母、数字、下划线和$组成
  - 不能由数字开头
  - 不能使用关键字和保留字、但是可以包含
  - 严格区分大小写，长度无限制
  - 标识符不能包含空格
- 命名规范
  - 包名：多单词组成时，所有字母都小写
  - 类名、接口名：多单词组成时，所有单词的首字母大写
  - 变量名、方法名：多单词组成时，第一个单词的首字母小写，第二个及以后单词首字母大写
  - 常量名：所有字母都大写，多单词时，每个字母用下划线连接

### 3.2-变量

- 构成及声明格式
  - 构成：数据类型、变量名、存储的值
  - 格式：数据类型  变量名  =  变量值
- 说明
  - 变量都有作用域，只在作用域内有效，作用域：{}
  - 同一个作用域内，不能声明两个同名的变量
  - 变量值在赋值时，必须满足变量的数据类型，并且在数据类型有效的范围内变化

### 3.3-Java的数据类型

- 基本数据类型(8种)：

  - 整型：byte、short、int、long(赋值时必须以L结尾)

    | 类型  | 占用存储空间 | 表数范围               |
    | ----- | ------------ | ---------------------- |
    | byte  | 1字节=8bit   | -128~127               |
    | short | 2字节        | -2的15次方~2的15次方-1 |
    | int   | 4字节        | -2的31次方~2的31次方-1 |
    | long  | 8字节        | -2的63次方~2的63次方-1 |

  - 浮点型：float(可以精确到7位有效数字，后缀为F)、double

    | 类型         | 占用存储空间 | 表数范围             |
    | ------------ | ------------ | -------------------- |
    | 单精度float  | 4字节        | -3.403E38~3.403E38   |
    | 双精度double | 8字节        | -1.798E308~1.798E308 |

    - 浮点型变量的精度不高，开发中使用应以BigDecimal类替换浮点型变量

  - 字符型：char

    - 两个字节
    - 表示形式1：使用 '' 表示，内部有且仅有一个字符
    - 表示形式2：使用 '' 表示，直接使用Unicode值来表示字符型常量，如：'\u0036'
    - 表示形式3：使用 '' 表示，使用转义字符
    - 表示形式4：使用具体字符对应的值(ASCII)

  - 布尔型：boolean

    - 在分配内存时，会被看成0和1，分配的内存和int类型相同

- 引用数据类型

  - 类(class)
  - 数组(array)
  - 接口(interface)
  - 枚举(enum)
  - 注解(annotation)
  - 记录(record)

### 3.5-基本数据类型运算规则

- 自动类型提升
  - 当容量小的变量与容量大的变量做运算时，结果自动转为容量大的数据类型
  - 特殊：byte和short运算时，结果为int类型
  - long超出8个字节，必须使用L结尾；低于8个字节int会转为long
- 强制类型转换
  - 强制类型转换是将容量大的变量类型转换为容量小的变量类型
  - 强制类型转换需要使用强转符：（），在()内指明要转换为的数据类型
  - 强制类型转换可能会造成精度丢失；如float->int，int->byte

5. String数据类型

   - 只能参与连接运算，且可以和boolean运算，结果为String类型

6. 运算符

   - %，符号与被模数符号相同

## 04-流程控制语句

### 4.1-三种循环的选择

- 遍历有明显的循环次数（范围）的需求，选择for循环
- 遍历没有明显的循环次数（范围）的需求，选择while循环
- 如果循环体语句块至少执行一次，可以考虑使用do-while循环

## 05-数组

### 5.1-数组的概述

- 数组可以理解为多个数据的组合
- 是程序中的容器：数组、集合框架(List、Map、Set)
- 数组存储的数据的特点：依次紧密排列的、有序的、可重复的
- 此时的数组、集合框架都是在内存中对数据的存储
- 数组的其他特点：一旦初始化，其长度就是确定的、不可更改的

### 5.2-一维数组的使用

- 数组的初始化
- 数组元素的调用
- 数组属性
- 数组的遍历
- 数组元素的默认初始化值
- 一维数组的内存解析

### 5.3-二维数组的使用

### 5.4-数组常用的算法

- 数组特征值的计算：最大值、最小值、求和、求平均值
- 数组元素的赋值：杨辉三角、随机六位数字、回形数
- 数组的赋值、复制
- 数组的反转 
- 数组的扩容、缩容
- 数组的查找
  - 线性查找
  - 二分查找（顺序的）
- 数组的排序
  - 冒泡排序 (最简单)
  - 快速排序 (最常用)

### 5.5-Arrays工具类的使用

- toString()
- sort()
- binarySearch()

### 5.6-数组中常见的异常

- ArrayIndexOutOfBoundsException
- NullPointerException

## 06-面向对象(基础)

### 6.1-类、对象

- 类：抽象的，概念上的定义
- 对象：具体的，类的实例
- 面向对象三步骤
  - 步骤一：创建一个类，并设计类的内部成员（属性、方法）
  - 步骤二：创建类的对象，例：Person person = new Person()
  - 步骤三：通过对象调用类内部声明的属性或方法，完成对应功能

### 6.2-Java中内存结构的划分

- 虚拟机栈：

  - 以栈帧为基本单位，有入栈和出栈操作，

  - 每个栈帧入栈操作对应一个方法；
  - 方法的局部变量存储在栈帧中。
- 堆空间：

  - new出来的结构(数组、对象)
  - 数组的元素在堆中
  - 对象的成员变量在堆中
- 方法区：加载的类的模板结构
- 程序计数器
- 本地方法栈
- 线程共享：方法区、堆空间
- 线程独占：虚拟机栈、本地方法栈、程序计数器

### 6.3-类的成员

- 类的成员之一：属性(成员变量)
  - 属性和局部变量
    - 声明的位置不同，类中和方法中
    - 内存中的存放位置不同，堆中和栈帧中
    - 作用域不同
    - 权限修饰符，属性可以有，局部变量没有
    - 初始化值：属性有默认值，局部变量调用前必须显式赋值
    - 生命周期不同，属性随着对象的创建而创建，局部变量随着方法的调用而创建
  - 属性 <=> 成员变量 <=> 字段、域 <=> field
- 类的成员之二：方法
  - 方法的声明：权限修饰符 返回值类型 方法名(形参列表){方法体}
  - 方法的重载：
    - 两同一不同：同一个类、相同的方法名、不同的参数列表(个数、类型)
    - 通过方法名、参数列表确定调用一个指定的方法
  - 方法的参数传递机制（值传递机制）
    - 如果是基本数据类型，则将实参保存的数据值传递给形参
    - 如果是引用数据类型，则将实参保存的地址值传递给形参
- 类的成员之三：构造器
  - 定义：权限修饰符 类名(形参列表){}
  - 作用：
    - 搭配上new，创建类的实例对象
    - 初始化对象的成员变量

### 6.4-oop特征之一：封装性

- 修饰符
  - Java规定了4中权限修饰，分别是public、protected、缺省、private
  - 我们可以使用4种权限修饰符来修饰类及类的内部成员，当这些成员被调用时，体现可见性的大小
- 使用场景
  - 场景一：私有化类的属性，通过提供公共的get和set方法，对此属性进行获取和修改
  - 场景二：将类中不需要对外暴露的方法，设置为private
  - 场景三：单例模式中构造器设置为private，避免在类的外部创建实例
- 理论上
  - 高内聚：类的内部操作数据自己完成，不允许外部干涉
  - 低耦合：仅暴露少量的方法给外部使用，尽量避免外部调用

### 6.5-三个知识点

- 对象的成员变量的赋值过程
  - 可以给属性赋值的位置
    - 默认初始化
    - 显式赋值
    - 构造器
    - 对象.属性
    - 对象.方法
  - 执行顺序
    - 1 -> 2 -> 3 -> 4/5
- JavaBean
  - 符合以下标准的java类
    - 类是公共的
    - 有一个无参的公共构造器
    - 有属性，且有对应的get和set方法
- UML类图

### 6.6-package、import关键字

- package：指明声明的类所属的包
- import：当前类中，如果要使用其他包下的类，原则上需要导入

### 6.7-对象数组

- String[]

## 07-面向对象(进阶)

### 7.1-关键字：this

1. 声明一个属性对应的set方法时，通过形参给对应的属性赋值
   - 当形参名和属性名一致时，可以通过this修饰属性，从而区分形参和属性
2. this的理解：当前创建的对象(方法) 或 当前正在创建的对象(构造器)
3. this可以调用的结构：成员变量、方法、构造器
   - this调用属性
     - 如果方法的形参和对象的属性重名，必须使用this进行区分，使用this修饰的变量即为属性(成员变量)，没有使用this修饰的属性即为局部变量
   - this调用方法
     - 通过对象调用方法，可以调用该对象的属性和其他方法，此时可以使用this调用属性和其他方法，this表示调用当前属性和方法所属的对象。一般情况下，会省略this
   - this调用构造器
     - 格式：通过 this(形参列表) 在类的构造器中调用其他构造器
     - 要求：this(形参列表) 必须声明在构造器的首行
     - 结论：this(形参列表) 在构造器中最多声明一个
     - 如果一个类中有n个构造器，则最多有n-1个 this(形参列表)；不能调用自己

### 7.2-面向对象特征二—继承

1. 继承的好处

   - 减少了代码冗余，提高了代码的可复用性
   - 继承的出现，更有利于功能的扩展

2. 继承的格式

   - ```java
     class A{
         // 属性
         // 方法
     }
     
     class B extends A{}
     ```

   - 类A：父类、超类、基类、superClass

   - 类B：子类、派生类、subClass

3.  有了继承性之后

   - 子类获取到父类中所有的属性和方法
   - 由于封装性的影响，可能子类中不能直接调用父类中声明的属性或方法
   - 子类在继承父类之后，还可以扩展自己的功能(特有的属性、方法)

4. 默认父类

   - Java中声明的类，如果没有显式声明其父类，则默认继承于java.lang.Object

### 7.3-方法的重写

1. 重写
   - 子类覆盖父类中同名同参数的方法
2. 为什么需要重写
   - 子类在继承父类之后，就获取了父类所声明的所有方法。但父类中的方法可能不太适用于子类，此时就要对继承的方法进行覆盖、覆写的操作
3. 方法重写的规则
   - 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同
   - 子类重写的方法权限修饰符不得小于父类被重写方法的权限修饰符
     - 子类不能重写父类private修饰的方法
   - 关于返回值类型
     - 父类被重写方法的返回值类型是void，则子类重写方法的返回值类型必须是void
     - 父类被重写方法的返回值类型是基本数据类型，则子类重写方法的返回值类型必须是基本数据类型
     - 父类被重写方法的返回值类型是引用数据类型，则子类重写方法的返回值类型可以是引用数据类型，也可以是被重写方法的返回值类型的子类

### 7.4-关键字：super

1. 为什么需要super
   - 父类的方法在子类中被重写，是否还可以在子类中调用父类中被重写的方法
   - 子类中出现和父类中同名的属性，如何进行区分
2. super可以调用的结构
   - 属性、方法
     - 如果子类重写了父类的方法或者出现了与父类同名的属性，则必须使用super.声明，显式的调用父类中的方法或属性
   - 构造器
     - 子类继承时，不会继承父类的构造器，但可以通过super(形参列表)调用父类的构造器
     - super(形参列表)必须放在首行
     - 在构造器中，super和this只能出现一个
     - 子类构造器中，若没有this或者super，则默认调用super(形参列表)
     - 通过子类的构造器创建对象时，一定会直接或者间接调用父类的构造器，正因为调用了父类的构造器，才会将父类声明的属性或方法加载到内存，供子类对象使用

### 7.5-面向对象的特征三—多态

1. 多态性的体现
   - 子类对象的多态性：父类的引用指向子类的对象（子类的对象赋给父类的引用）
2. 多态性的应用
   - 虚拟方法调用
     - 编译时，认为方法是左边声明的父类的类型的方法
     - 运行时，实际执行的是子类重写的父类的方法
     - 编译看左边，运行看右边（方法）
     - 编译、运行都看左边（属性）
3. 多态性的使用前提
   - 要有类的继承
   - 要有方法的重写
4. 多态的适用性
   - 仅适用于方法，不适用属性
5. 多态的好处和弊端
   - 好处
     - 极大的减少了代码的冗余，不需要定义多个重载的方法
   - 弊端
     - 在多态的场景下，创建了子类的对象，也加载了子类特有的属性和方法，但是由于声明为父类的引用，导致没有办法直接调用子类特有的属性和方法。

6. 向下转型
   - 向上转型 <=> 多态
   - 向下转型  Man man = (Man)  person
   - 使用instanceof可以判断一个对象是否是某个对象的实例

### 7.6-Object类

1. 概述

   - 任何一个类都间接或直接继承于Object类
   - Object类中没有声明属性
   - Object类提供了一个空参的构造器
   - Object类中的方法(重点)

2. 常用方法

   - 重点方法
     - equals()、toString()
   - 了解方法
     - clone()：克隆一个对象
     - finalize()：垃圾回收器回收此对象时调用(临死之前的遗言)，可能导致内部出现循环引用
   - 目前不需关注
     - getClass()
     - 反射：hashCode()
     - 多线程：notify()、notifyAll()、wait()、wait(xx)、wait(xx,yy)

3. equals()的使用

   - 适用性

     - 任何引用类型都可以使用

   - 子类使用说明

     - 比较两个对象的引用地址是否相同
     - 对于String、File、Date和包装类等，都重写了Object的equals方法，不再比较地址，而是判断实体内容是否相同

   - 重写equals

     ```java
      public boolean equals(Object obj) {
             if (this == obj) {
                 return true;
             }
     
             if (obj instanceof User) {
                 User user = (User) obj;
                 return this.age == user.age && this.name.equals(user.name);
             }
     
             return false;
         }
     ```

   - == 和 equals 的区别

     - ==：运算符
       - 使用范围：基本数据类型、引用数据类型
       - 基本数据类型：判断数据值是否相等
       - 引用数据类型：判断地址值是否相等
     - equals：方法
       - 使用范围：引用数据类型
       - 类中的重写：不再判断地址值

4. toString()的使用

   - 子类使用说明

     - 自定义的类，在没有重写Object.toStirng()方法时，默认打印的是当前对象的地址值
     - 对于String、File、Date和包装类等，重写了toString()方法，打印的是实体内容

   - 重写toString

     ```java
     public String toString(){
     	return "User{name ="+name+",age="+age+"}"
     }
     ```

### 7.7-复习

1. this关键字的使用

   - this调用的结构：属性、方法、构造器
   - this调用属性或方法：可以根据位置不同理解this为当前创建的对象或当前正在创建的对象
   - this调用构造器：this(形参列表)，必须放在首行

2. 面向对象的特征二—继承性

   - 继承性的好处：
     - 减少了代码的冗余，提高了复用性
     - 提高了扩展性
     - 为多态的使用提供了前提
   - Java中继承性的特点
     - 局限性：类的单继承性。后续可以通过类实现接口的方式，解决单继承性的缺点
     - 支持多层继承，一个父类可以声明多个方法
   - 理解：子类继承父类的全部属性和方法，但是受封装性的影响，不能直接调用

3. 方法的重写

   - 重载和重写的区别
     - 重载
       - 同一个类、方法名相同
       - 形参列表不同
     - 重写
       - 类的继承关系
       - 子类对父类同名同参数的方法的覆盖、覆写

4. super关键字的使用

   - super调用的结构：属性、方法、构造器
   - super调用属性或方法：
     - 子类中出现了和父类相同的属性，通过super.调用父类中的属性
     - 子类重写了父类的方法，通过super.调用父类中的方法
   - super调用构造器：子类构造器中使用super(参数列表)调用父类中的构造器，默认调用父类的空构造器

5. 面向对象的特征三—多态性

   - 子类对象的多态性、方法的重写

   - 理解：父类的引用指向子类的对象
   - 好处：减少了大量的重载方法的定义；开闭原则 
   - 使用：虚拟方法调用，编译看左边，执行看右边
   - 注意：属性没有多态性
   - 多态逆过程：向下转型、强转符、instanceof判断

6. Object类的使用

   - equals()方法
     - 返回地址值比较的结果
     - 重写后返回对象的实体内容比较的结果
     - == 和 equals
   - toString()方法
     - 返回当前对象所属的类和地址值
     - 重写后返回当前对象的属性信息

## 08-面向对象(高级)

### 8.1-关键字：static

1. 修饰的结构

   - 属性、方法、代码块、内部类

2.  static修饰属性

   - 变量分类
     - 成员变量
       - 使用static修饰：静态变量、类变量
       - 不使用static修饰：非静态变量、实例变量
     - 局部变量
       - 方法内、方法形参、构造器内、构造器形参、代码块内
   - 静态变量和实例变量的区别
     - 个数
       - 静态变量：内存空间中只有一份，被类的所有对象共享
       - 实例变量：类的每一个实例对象都保存着一份实例变量
     - 内存位置
       - 静态变量：jdk6之前，存放在方法区；jdk7及以后存放在堆空间
       - 实例变量：存放在堆空间的对象实体中
     - 加载时机
       - 静态变量：随着类的加载而加载，类只会加载一次，因此只有一份
       - 实例对象：随着类的对象的创建而加载，每个对象都有一份
     - 调用者
       - 静态变量：类和对象都可以直接调用
       - 实例变量：只能使用对象进行调用
     - 消亡时机
       - 静态变量：随着类的卸载而消亡
       - 实例变量：随着对象的消亡而消亡

3. static修饰方法
   - 可以通过 类.静态方法 的格式调用静态方法
   - 静态方法内可以调用静态的方法或静态的属性
   - 不可以调用非静态的结构（属性、方法）
   - static方法内不能使用 this 也不能使用 super
4. 什么时候需要将属性声明为静态的
   - 类的多个实例共享此成员变量，且此成员变量的值是相同的
   - 将一些常量声明为静态的，例：Math.PI
5. 什么时候需要将方法声明为静态的
   - 对于静态变量的get和set方法，可以声明为静态的方法
   - 将工具类中的方法声明为静态的，例：Arrays、Math

### 8.2-单例模式

1. 何为单例模式

   - 采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

2. 如何实现单例模式

   - 饿汉式

     ```java
     public class BankTest {
         public static void main(String[] args) {
             Bank bank = Bank.getInstance();
         }
     }
     
     class Bank {
         // 2. 类的内部创建当前类的实例，属性必须为static
         private static Bank instance = new Bank();
     
         // 1. 类的构造器私有化
         private Bank() {
         }
     
         // 3. 使用get方法获取当前类的实例，必须声明为static
     
     
         public static Bank getInstance() {
             return instance;
         }
     }
     ```

     

   - 懒汉式

     ```java
     public class GirlFriendTest {
         public static void main(String[] args) {
             GirlFriend girlFriend = GirlFriend.getInstance();
         }
     }
     
     class GirlFriend {
         // 2. 类的内部创建当前类的实例
         private static GirlFriend instance = null;
     
         // 1. 类的构造器私有化
         private GirlFriend() {
         }
     
         // 3. 提供对应的get方法
     
         public static GirlFriend getInstance() {
             if (instance == null) {
                 instance = new GirlFriend();
             }
             return instance;
     
         }
     }
     ```

3. 饿汉式和懒汉式对比

   - 饿汉式：立即加载，随着类的加载，当前的唯一实例就创建了
     - 优点：写法简单，由于内存中较早加载，使用更方便、更快，线程安全
     - 缺点：内存中占用时间较长
   - 懒汉式：延迟加载，在需要使用的时候，进行创建
     - 优点：在需要的时候进行加载，节省内存空间
     - 缺点：线程不安全

### 8.3-类的成员四—代码块

1. 代码块的作用
   - 用来初始化类或对象的信息（即初始化类或对象的成员的变量）
2. 代码块的修饰
   - 只能使用static进行修饰
3. 代码块的分类
   - 静态代码块
   - 非静态代码块
4. 具体使用
   - 静态代码块
     - 随着类的加载而执行
     - 由于类的加载只会执行一次，静态代码块也因此只会执行一次
     - 用来初始化类的信息
     - 内部可以声明变量、调用属性或方法、编写输出语句等操作
     - 静态代码块内部只能调用静态的结构
   - 非静态代码块
     - 随着对象的创建而执行
     - 每创建当前类的实例，就会执行一次非静态代码块
     - 用来初始化对象的信息
     - 内部可以声明变量、调用属性或方法、编写输出语句等操作
     - 非静态代码块内部可以调用静态和非静态的结构

### 8.4-属性赋值的过程

1. 给类的非静态属性赋值的位置有：
   1. 默认初始化
   2. 显式初始化
   3. 构造器中初始化
   4. 通过对象.属性赋值
   5. 代码块中初始化

### 8.5-关键字：final

1. final可以用来修饰的结构
   - 类：表示该类不能被继承
   - 方法：表示此方法不能被重写
   - 变量：表示该变量为常量
     - 成员变量：显式赋值、代码块、构造器
     - 局部变量：在调用之前一定要赋值
2. final和static搭配使用
   - 修饰成员变量时：全局常量，只有一个

### 8.6-关键字：abstract

1. 可以修饰的结构
   - 类：抽象类，不能实例化，可以有构造器
   - 方法：抽象方法，只有方法的声明，没有方法体
   - 抽象方法所在的类必须是抽象类
2. 不能与哪些关键字公用
   - private方法：私有方法不能被重写
   - static方法：避免静态方法通过类调用
   - final方法：不能被重写
   - final类：不能被继承

### 8.7-关键字：interface

1. 接口的理解

   - 接口的本质是契约、标准、规范

2. 接口内部结构

   - 可以声明
     - 属性：public static final
     - 方法：public abstract 一般用于声明抽象方法；也可以声明静态方法、私有方法
   - 不可以声明
     - 构造器
     - 代码块

3. 接口和类

   - 类相对于实现的接口：实现类

   - 类可以实现多个接口
   - 类针对于接口的多实现，一定程度上弥补了类的但继承性的缺点
   - 类中必须将实现的接口中的所有抽象方法都重写，方可实例化

4. 接口和接口

   - 接口之间可以实现多继承

5. 接口的多态性

   - 接口 变量名 = new 实现类

6. 区分抽象类和接口

   - 共性
     - 都可以声明抽象方法
     - 都不能被实例化
   - 不同
     - 抽象类有构造器，接口没有
     - 类与类之间是继承关系，类与接口之间是实现关系

7. JDK8之后新特性

   - 静态方法
     - 只能通过 接口名.方法调用
     - 不能通过实现类调用
   - 默认方法
     - 可以被实现类继承，可以重写此方法
     - 实现两个接口，接口中定义了同名同参的方法
       - 若没有重写，则会出现接口冲突
   - 子类继承了父类，并实现了接口，若父类和接口中出现同名同参的方法
     - 若没有重写，默认调用父类中的方法（类优先原则）
   - 调用接口中被重写的方法
     - 单个接口
       - super.方法名
     - 多个接口
       - 接口名.super.方法名
   - JDK9之后新特性
     - 私有方法

### 8.8-类的成员五—内部类

1. 内部类
   - 将一个类A定义在另一个类B的内部，类A被称为内部类，类B被称为外部类
2. 内部类的分类
   - 成员内部类
     - 定义在外部类的里面
       - 使用static修饰的，静态的成员内部类
       - 不使用static修饰的，非静态的成员内部类
   - 局部内部类
     - 声明在方法内、构造期内、代码块内的内部类
       - 匿名的局部内部类
       - 非匿名的局部内部类
3. 关于成员内部类
   - 从类的角度看
     - 内部可以声明属性、方法、构造器、代码块、内部类
     - 此内部类可以继承父类、实现接口
     - 可以使用final和abstract修饰
   - 从外部类的成员看
     - 在内部可以调用外部的结构，属性或方法等
     - 除了使用public和缺省修饰符外，还可以使用private和protected修饰
     - 可以使用static修饰
4. 关于局部内部类
   - 和成员内部类不同的是，不能有修饰符
   - 如同局部变量一般，有作用域
   - 是否可以访问外部的结构，取决于所在的方法

### 8.9-枚举类

1. 概述
   - 枚举类本质上也是一种类，只不过这个类的对象是有限的，固定的几个，不能让用户随意创建
   - 例子：星期、性别、月份、季节、订单状态等，都是有限的
   - 如果枚举类的实例只有一个，可以看做是单例的实现方式
2. 定义枚举类
   - 定义：enum 类名{ 提供对象实例 }
   - 使用：类名.实例名.属性/方法
   - 枚举类默认父类Enum
3. Enum常用的方法
   - toString()：默认返回的是对象名，可以重写此方法
   - values()：返回枚举类型的对象数组，是一个静态方法，可以很快的遍历所有的枚举值（重点）
   - valuesOf(String name)：查找字符串对应的枚举类对象，找不到报错（重点）
   - String name()：返回当前枚举对象的名称
   - int ordinal()：返回当前枚举对象的次序号，默认从0开始
4. 枚举类实现接口的情况
   - 让枚举类实现接口，在枚举类中重写接口中的抽象方法，通过不同的枚举对象调用此方法时，调用的是同一个方法
   - 让枚举类中的对象重写接口中的抽象方法，通过不同的枚举对象调用此方法时，调用的是不同的方法

### 8.10-注解

1. 概述
   - 注解可以看成是一种注释，通过使用Annotation，在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。
   - 注解可以被编译器和其他程序读取，程序可以根据注解的不同，做出对应的处理
2. 应用场景
   - 生成文档相关注释
   - 在编译时进行格式检查（JDK内置的三个基本注解 ）
   - 跟踪代码依赖性，实现替代配置文件功能
3. 三个基本注解
   - @Override：限定重写父类方法，只能用于方法
   - @Deprecated：用于表示所修饰的元素（类、方法）已经过时。通常是因为所修饰的结构危险或存在更好的选择。注：只是不建议使用，但还可以使用
   - @SuppressWarnings：抑制编译器警告
4. 元注解
   - 对现有注解进行解释说明的注解
     - @Target：用于描述注解的使用范围
     - @Retention：用于描述注解的生命周期
     - @Documented：表示这个注解应该被javadoc工具记录
     - @Inherited：允许子类继承父类中的注解

### 8.11-包装类

1. 概述

   - 包装类是针对于基本数据类型，使得基本数据类型有了类的特征

   - 八种包装类：

     | 数据类型 | 包装类  | 数据类型 | 包装类    |
     | -------- | ------- | -------- | --------- |
     | byte     | Byte    | float    | Float     |
     | short    | Short   | double   | Double    |
     | int      | Integer | char     | Character |
     | long     | Long    | boolean  | Boolean   |

   - 数值型包装类的父类为Number

2. 基本数据类型与包装类之间的转换

   - 基本数据类型 => 包装类
     - 使用包装类的构造器；例：Integer i = new Interget(10)
     - 使用valueOf()方法；例：Float f = new Float.valueOf(12.3F)  （推荐使用）
   - 包装类 => 基本数据类型
     - 使用xxxValue()；例：float f1 = f.floatValue();

3. 自动装箱、自动拆箱

   - Integer i = 10;  int i1 = i;

4. 基本数据类型和包装类默认值的区别

   - Boolean 和  boolean  <=>  null 和 false
   - Double 和  double  <=>  null  和  0.0

5. 基本数据类型、包装类转换为String

   - 基本数据类型、包装类 => String
     - String.valueOf()；例：String s = String.valueOf()
     - +” “
   - String => 基本数据类型、包装类
     - 包装类的parseXXX()；例：int i = Integer.parseInt()

6. 包装类对象的特点

   - 包装类缓存对象

     | 包装类    | 缓存对象    |
     | --------- | ----------- |
     | Byte      | -128~127    |
     | Short     | -128~127    |
     | Integer   | -128~127    |
     | Long      | -128~127    |
     | Float     | 没有        |
     | Double    | 没有        |
     | Character | 0~127       |
     | Boolean   | true和false |

### 8.12-复习

1. 关键字：static
   - static：静态的，随着类的加载而加载、执行
   - static用来修饰：属性、方法、代码块、内部类
   - static修饰的属性和方法与不使用static修饰的区别
     - 类属性：内存空间中只有一份，被所有实例对象共享
     - 类方法：不可以调用非静态的结构，也不能使用this和super，不能被重写
2. 单例模式
   - 解决的问题：在整个软件系统中，只存在当前类的唯一实例
   - 实现方式：饿汉式、懒汉式、枚举类等
   - 对比饿汉式和懒汉式
     - 饿汉式：立即加载、线程安全
     - 懒汉式：延迟加载、线程不安全
3. 类的成员四—代码块
   - 根据static修饰，分为静态代码块和非静态代码块
   - 静态代码块：随着类的加载而执行
   - 非静态代码块：随着对象的创建而调用
   - 属性的赋值位置：
4. 关键字：final
   - 用来修饰：类、方法、变量
     - 类：不能被继承
     - 方法：不能被重写
     - 变量：一旦赋值不能被更改
5. 关键字：abstract
   - 用来修饰：类、方法
     - 类：不能被实例化
     - 方法：不能有方法体，必须由子类重写此方法
6. 关键字：interface
   - 用来定义规范的
   - 接口中可以声明的结构
     - 属性：public static final
     - 方法：public abstract；jdk8：static、default方法；jdk9：private
7. 类的成员之五：内部类
   - 成员内部类
     - 从类的角度看
       - 可以声明属性、方法、构造器、代码块、内部类等结构
       - 可以继承父类，实现接口
       - 可以使用final修饰
       - 可以被abstract修饰
     - 从外部类的成员看
       - 可以调用外部类的结构：属性、方法
       - 可以使用static修饰
       - 除了public和缺省外，还可以使用private和protected修饰
   - 局部内部类
8. 枚举类
9. 注解
10. 包装类
    - 基本数据类型、包装类、String之间的数据转换
      - 基本数据类型 <=> 包装类：自动拆箱、自动装箱
      - 基本数据类型、包装类 <=>  String：
        - String的valueOf(xx)
        - 包装类的parseXXX(String xx)

## 09-异常处理

### 9.1-常见错误和异常

1. Throwable
   - java.lang.Throwable类是java程序运行过程中发生的异常事件对应的类的根父类
   - Throwable中常用的方法：
     - public void printStackTrace()：打印异常的详细信息，包括异常类型、原因、出现的位置
     - public String getMessage()：获取发生异常的原因
2. Error和Exception
   - Error：对应java.lang.Error类
     - java虚拟机无法解决的严重问题。一般不编写针对性的代码进行处理
       - StackOverFlowError：栈溢出
       - OutOfMemoryError：堆溢出
   - Exception：对应java.lang.Exception类
     - 因编程错误或偶然的外部因素导致的一般性问题，需要使用针对性的代码进行处理，否则程序也会挂
     - 运行时异常
       - NullPointerException：空指针异常
       - ArrayIndexOutOfBoundsException：数组角标越界 
       - ClassCastException：强转异常；Date date  = (Date) obj
       - NumberFormatException  数字格式异常；String 123a 转 int
       - InputMismatchException  输入不匹配异常；接收int，输入字符串
       - ArithmeticException  算术异常；除以0
     - 编译时异常
       - ClassNotFoundException
       - FileNotFoundException
       - IOException

### 9.2-异常的处理

1. 异常处理方式一：try-catch-finally

   - 执行过程
     - 过程1：程序在执行的过程中，一旦出现异常，就会在异常的代码处，生成对应异常类的对象，并将此对象抛出，一旦抛出，此程序就不再执行其后的代码了
     - 过程2：针对于过程1抛出的异常对象，进行捕获处理，一旦将异常进行了处理，代码就可以继续执行了

   - 基本结构

     ```java
     try{
     	// 可能出现异常的代码
     }catch(异常类型1 e){
         // 当产生异常类型1时的处置措施
     }catch(异常类型2 e){
         // 当产生异常类型2时的处置措施
     }finally{
         // 无论是否发生异常，都无条件执行的语句
     }
     ```

   - 使用细节

     - 将可能出现的异常声明在try中，一旦代码出现异常，就会自动生成一个对应的异常类对象，并抛出
     - 针对于try中抛出的异常类对象，使用catch语句进行匹配，一旦匹配到，就进入catch语句块处理
     - 如果声明了多个catch结构，不同的异常类型在不存在子父类的情况下，谁声明在上、在下都可以；如果多个异常类型满足父子类的关系，则必须将子类声明在父类的上面，否则报错

   - catch中异常处理的方式

     - 自己编写输出的语句
     - printStackTrace()：打印异常的详细信息（推荐）
     - getMessage()：获取发生异常的原因

   - 开发体会

     - 对于运行时异常，通常不使用异常处理，直接根据异常结果修改代码即可
     - 对于编译时异常，一定要处理，否则编译不通过

   - finally使用

     - finally理解
       - 将一定会执行的代码写在finally中
       - 无论try..catch中是否存在未被处理的异常或存在return，finally中的语句一定会被执行
       - 例外：System.exit(0)执行，程序结束，finally不再执行
       - finally不能单独定义，必须结合try...catch使用
     - 使用场景
       - 开发中有一些资源（输入流、输出流、数据库连接、Sorcket连接等资源），在使用完之后，必须显示的进行关闭操作，否则，GC不会自动回收这些资源，进而导致内存的泄露
       - 为了保证这些资源在使用完成之后，不管是否出现未被处理异常的情况下，这些资源都能关闭，我们必须这些关闭操作声明在finally中

2. 异常处理方式二：throws

   - 格式：在方法的声明时，使用 throws 异常类型1，异常类型2....
   - 处理异常
     - 将异常抛给调用此方法的地方去解决，没有真正解决异常
   - 方法重写的要求
     - 子类重写的方法抛出的异常类型可以与父类被重写方法抛出的异常类型相同，或是父类被重写方法抛出的异常类型的子类
     - 因为真正使用try...catch解决异常时，是解决父类的异常（编译看左边），若运行时子类抛出更大的异常，解决不了

3. 开发中如何选择两种异常处理方式（重要）

   - 涉及到资源的调用：try...catch...finally
   - 父类被重写的方法没有throws异常类型，子类重写的方法出现了异常：try...catch...finally
   - 方法a中调用了b、c、d方法：a中使用try...catch...finally，b、c、d中使用throws抛给a统一解决

### 9.3-手动抛出异常

1. 手动抛出异常场景
   - 实际开发中，不满足具体场景的代码问题，手动抛出指定类型的异常对象
2. 语法格式：throw new 异常类型()

### 9.4-自定义异常类

1. 如何自定义异常类
   - 继承于现有的异常体系。通常继承于Exception或RuntimeException
   - 通常提供几个重载的构造器，接收异常信息
   - 提供一个全局常量，声明为：static final  long  serialVersionUID = -43475984723957589437L;
2. 为什么需要自定义异常类
   - 通过异常的名称就能直接判断此异常的原因
   - 不满足我们指定的条件时，指明我们特有的异常类，从而判断出具体出现的问题 

### 9.5-复习

1. 异常的概述
   - 什么是异常
     - 程序在执行过程中，出现的非正常情况，如果不处理会导致JVM的非正常停止
   - 异常的抛出机制
     - Java中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类对象，并抛出，程序员可以捕获这个异常，并进行处理；如果没有捕获这个异常对象，那么这个异常对象将会致程序终止
2. 异常的体系结构及常见异常
   - Throwable异常体系的父类
   - Error：错误，JVM系统内部错误，资源耗尽等严重情况，一般不编写代码进行处理
     - StackOverflowError(栈溢出)、OutOfMemoryError(堆溢出)
   - Exception：异常，我们可以编写针对性代码进行处理
     - 运行时异常
       - ArrayIndexOutOfBoundsException
       - NullPointerException
       - ClassCastException
       - NumberFormatException
       - InputMismatchException
       - ArithmeticException
     - 编译时异常
       - ClassNotFoundException
       - FileNotFoundException
       - IOException
3. 异常的处理方式
   - try-catch-finally
   - throws
4. 手动抛出异常对象
   - throw new 异常对象
5. 如何自定义异常类
   - 定义一个类继承异常类
   - 提供几个重载的构造器
   - 提供一个全局常量声明为 public static final long serialVersionUID:

## 10-多线程

### 10.1-相关概念

1. 程序、进程、线程的区分
   - 程序：为完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码
   - 进程：程序的一次执行过程，或是正在内存中运行的应用程序。程序是静态的，进程是动态的。
     - 进程作为操作系统调度和分配资源的最小单位
   - 线程：进程可进一步细化为线程，是程序内部的一条执行路径
     - 线程作为CPU调度和执行的最小单位
2. 线程调度策略
   - 分时调度：所有线程轮流使用CPU，并且平均分配每个线程占用CPU的时间
   - 抢占式调度：让优先级高的线程以较大的概率优先使用CPU，若优先级相同，则随机选择一个线程

### 10.2-创建和启动线程

1. 概述
   - java.lang.Thread类代表线程，所有线程都必须是Thread类或其子类的实例
2. 创建方式
   - 继承Thread类
     - 创建一个继承于Thread类的子类
     - 重写Thread类的run方法；将此线程要执行的操作，声明在此方法体中
     - 创建当前Thread子类的对象
     - 通过对象调用start()，启动线程，调用当前线程的run()
   - 实现Runnable接口
     - 创建一个实现Runnable接口的类
     - 实现接口中的run方法，将此线程要执行的操作，声明在此方法体中
     - 创建当前类的对象
     - 将此对象作为参数传递到Thread类的构造器中，创建Thread类的实例
     - Thread类的实例调用start()，启动线程，调用当前线程的run()
3. 对比两种创建方式
   - 共同点
     - 启动线程：使用Thread类中的start()
     - 创建的线程对象都是Thread或其子类的对象
   - 不同点
     - 一个是类的继承
     - 一个是接口的实现
       - 避免类的单继承的局限性
       - 更适合来处理有共享数据的问题
       - 实现了数据和代码的分离

### 10.3-线程的常用方法与生命周期

1. 线程中的构造器
   - public Thread()：分配一个新的线程对象
   - public Thread(String name)：分配一个指定名字的线程对象
   - public Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法
   - public Thread(Runnable target, String name)：分配一个带有指定目标新的线程对象并指定名字
2. 线程中的常用方法
   - start()：启动线程，调用线程的run方法
   - run()：将线程要执行的操作，声明在run方法中
   - currentThread()：获取当前执行代码对应的线程
   - getName()：获取当前线程的名称
   - setName()：更改当前线程的名称
   - sleep(long millis)：静态方法，延迟当前线程执行，指定延迟时间
   - yield()：一旦执行此方法，主动释放CPU执行权
   - join()：在线程a中通过线程b调用join()，意味着线程a进入线程阻塞状态，知道线程b执行结束，才执行a
   - isAlive()：判断线程是否存活，返回一个Boolean值
3. 过时方法
   - stop()：强行使线程进入死亡状态，不建议使用
   - suspend() / resume()：暂停和恢复

4. 优先级
   - getPriority()：获取当前线程的优先级
   - setPriority()：设置线程优先级，设置范围1-10
5. 线程的生命周期