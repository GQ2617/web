import{_ as a,c as e,o as t,d as s}from"./app.c282a12f.js";const M=JSON.parse('{"title":"集合类","description":"","frontmatter":{},"headers":[{"level":2,"title":"01-Java中有哪些容器（集合类）？","slug":"_01-java中有哪些容器-集合类","link":"#_01-java中有哪些容器-集合类","children":[]},{"level":2,"title":"02-Map接口有哪些实现类？","slug":"_02-map接口有哪些实现类","link":"#_02-map接口有哪些实现类","children":[]},{"level":2,"title":"03-HashMap有什么特点？","slug":"_03-hashmap有什么特点","link":"#_03-hashmap有什么特点","children":[]},{"level":2,"title":"04-HashMap为什么用红黑树而不用B树？","slug":"_04-hashmap为什么用红黑树而不用b树","link":"#_04-hashmap为什么用红黑树而不用b树","children":[]},{"level":2,"title":"05-HashMap如何实现线程安全？","slug":"_05-hashmap如何实现线程安全","link":"#_05-hashmap如何实现线程安全","children":[]},{"level":2,"title":"06-Map和Set有什么区别？","slug":"_06-map和set有什么区别","link":"#_06-map和set有什么区别","children":[]},{"level":2,"title":"07-List和Set有什么区别？","slug":"_07-list和set有什么区别","link":"#_07-list和set有什么区别","children":[]},{"level":2,"title":"08-介绍一下ArrayList的数据结构？","slug":"_08-介绍一下arraylist的数据结构","link":"#_08-介绍一下arraylist的数据结构","children":[]},{"level":2,"title":"09-说一说HashSet的底层结构","slug":"_09-说一说hashset的底层结构","link":"#_09-说一说hashset的底层结构","children":[]}],"relativePath":"Java/interview_java/Java基础/集合类.md"}'),h={name:"Java/interview_java/Java基础/集合类.md"},r=s('<h1 id="集合类" tabindex="-1">集合类 <a class="header-anchor" href="#集合类" aria-hidden="true">#</a></h1><h2 id="_01-java中有哪些容器-集合类" tabindex="-1">01-Java中有哪些容器（集合类）？ <a class="header-anchor" href="#_01-java中有哪些容器-集合类" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>Java中的集合类主要由Collection和Map这两个接口派生而出，其中Collection接口又派生出三个子接口，分别是Set、List、Queue。所有的Java集合类，都是Set、List、Queue、Map这四个接口的实现类，这四个接口将集合分成了四大类，其中</p><ul><li>Set代表无序的，元素不可重复的集合；</li><li>List代表有序的，元素可以重复的集合；</li><li>Queue代表先进先出（FIFO）的队列；</li><li>Map代表具有映射关系（key-value）的集合。</li></ul><p>这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。</p><h2 id="_02-map接口有哪些实现类" tabindex="-1">02-Map接口有哪些实现类？ <a class="header-anchor" href="#_02-map接口有哪些实现类" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>Map接口有很多实现类，其中比较常用的有HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap。</p><p>对于不需要排序的场景，优先考虑使用HashMap，因为它是性能最好的Map实现。如果需要保证线程安全，则可以使用ConcurrentHashMap。它的性能好于Hashtable，因为它在put时采用分段锁/CAS的加锁机制，而不是像Hashtable那样，无论是put还是get都做同步处理。</p><p>对于需要排序的场景，如果需要按插入顺序排序则可以使用LinkedHashMap，如果需要将key按自然顺序排列甚至是自定义顺序排列，则可以选择TreeMap。如果需要保证线程安全，则可以使用Collections工具类将上述实现类包装成线程安全的Map。</p><h2 id="_03-hashmap有什么特点" tabindex="-1">03-HashMap有什么特点？ <a class="header-anchor" href="#_03-hashmap有什么特点" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><ol><li>HashMap是线程不安全的实现；</li><li>HashMap可以使用null作为key或value。</li></ol><h2 id="_04-hashmap为什么用红黑树而不用b树" tabindex="-1">04-HashMap为什么用红黑树而不用B树？ <a class="header-anchor" href="#_04-hashmap为什么用红黑树而不用b树" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>B/B+树多用于外存上时，B/B+也被成为一个磁盘友好的数据结构。</p><p>HashMap本来是数组+链表的形式，链表由于其查找慢的特点，所以需要被查找效率更高的树结构来替换。如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。</p><h2 id="_05-hashmap如何实现线程安全" tabindex="-1">05-HashMap如何实现线程安全？ <a class="header-anchor" href="#_05-hashmap如何实现线程安全" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><ol><li>直接使用Hashtable类；</li><li>直接使用ConcurrentHashMap；</li><li>使用Collections将HashMap包装成线程安全的Map。</li></ol><h2 id="_06-map和set有什么区别" tabindex="-1">06-Map和Set有什么区别？ <a class="header-anchor" href="#_06-map和set有什么区别" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>Set代表无序的，元素不可重复的集合；</p><p>Map代表具有映射关系（key-value）的集合，其所有的key是一个Set集合，即key无序且不能重复。</p><h2 id="_07-list和set有什么区别" tabindex="-1">07-List和Set有什么区别？ <a class="header-anchor" href="#_07-list和set有什么区别" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>Set代表无序的，元素不可重复的集合；</p><p>List代表有序的，元素可以重复的集合。</p><h2 id="_08-介绍一下arraylist的数据结构" tabindex="-1">08-介绍一下ArrayList的数据结构？ <a class="header-anchor" href="#_08-介绍一下arraylist的数据结构" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>ArrayList的底层是用数组来实现的，默认第一次插入元素时创建大小为10的数组，超出限制时会增加50%的容量，并且数据以 System.arraycopy() 复制到新的数组，因此最好能给出数组大小的预估值。</p><p>按数组下标访问元素的性能很高，这是数组的基本优势。直接在数组末尾加入元素的性能也高，但如果按下标插入、删除元素，则要用 System.arraycopy() 来移动部分受影响的元素，性能就变差了，这是基本劣势。</p><h2 id="_09-说一说hashset的底层结构" tabindex="-1">09-说一说HashSet的底层结构 <a class="header-anchor" href="#_09-说一说hashset的底层结构" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>HashSet是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>',36),i=[r];function l(p,n,d,_,o,c){return t(),e("div",null,i)}const v=a(h,[["render",l]]);export{M as __pageData,v as default};
