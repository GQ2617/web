import{_ as l,c as s,o as i,d as a}from"./app.c282a12f.js";const y=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[{"level":2,"title":"01-常见的http status","slug":"_01-常见的http-status","link":"#_01-常见的http-status","children":[]},{"level":2,"title":"02-跨域及解决方法","slug":"_02-跨域及解决方法","link":"#_02-跨域及解决方法","children":[]},{"level":2,"title":"03-HTTP和HTTPS的区别","slug":"_03-http和https的区别","link":"#_03-http和https的区别","children":[]},{"level":2,"title":"04-地址栏输入URL之后","slug":"_04-地址栏输入url之后","link":"#_04-地址栏输入url之后","children":[]},{"level":2,"title":"05-GET和POST的区别","slug":"_05-get和post的区别","link":"#_05-get和post的区别","children":[]},{"level":2,"title":"06-HTTP常见的请求头","slug":"_06-http常见的请求头","link":"#_06-http常见的请求头","children":[]},{"level":2,"title":"07-TCP三次握手和四次挥手","slug":"_07-tcp三次握手和四次挥手","link":"#_07-tcp三次握手和四次挥手","children":[]},{"level":2,"title":"08-WebSocket","slug":"_08-websocket","link":"#_08-websocket","children":[]},{"level":2,"title":"09-CDN","slug":"_09-cdn","link":"#_09-cdn","children":[]},{"level":2,"title":"10-TCP和UDP","slug":"_10-tcp和udp","link":"#_10-tcp和udp","children":[]}],"relativePath":"Web/interview/前端进阶/HTTP.md"}'),n={name:"Web/interview/前端进阶/HTTP.md"},e=a(`<h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-hidden="true">#</a></h1><h2 id="_01-常见的http-status" tabindex="-1">01-常见的http status <a class="header-anchor" href="#_01-常见的http-status" aria-hidden="true">#</a></h2><ol><li><strong>2开头 （请求成功）表示成功处理了请求的状态代码。</strong><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li></ul></li><li><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul></li><li><strong>4开头 （客户端错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</strong><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时） 服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足&quot;期望&quot;请求标头字段的要求。</li></ul></li><li><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</li></ul></li></ol><h2 id="_02-跨域及解决方法" tabindex="-1">02-跨域及解决方法 <a class="header-anchor" href="#_02-跨域及解决方法" aria-hidden="true">#</a></h2><ol><li><p>概述</p><ul><li>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，知识结果被浏览器拦截了</li></ul></li><li><p>产生原因</p><ul><li>同源策略 <ul><li>同源策略是浏览器最核心也是最基本的安全功能</li><li>同源是指：协议+域名+端口 三者相同</li></ul></li></ul></li><li><p>常见的解决方案</p><ul><li><p>jsonp：利用script标签， 不受跨域限制的特点，缺点是只能支持get请求</p></li><li><p>cors：后端设置响应头 Access-Control-Allow-Origin</p></li><li><p>服务器代理：再devServer中配置proxy</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// vue.config.js</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">devServer</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">host</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">127.0.0.1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">port</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">8084</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">open</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// vue项目启动时自动打开浏览器</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">proxy</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">/api</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">target</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http://xxx.xxx.xx.xx:8080</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//目标地址，一般是指后台服务器地址</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">changeOrigin</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//是否跨域</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">pathRewrite</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">          </span><span style="color:#676E95;font-style:italic;">// pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&quot;&quot;代替</span></span>
<span class="line"><span style="color:#A6ACCD;">          </span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">^/api</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ol><h2 id="_03-http和https的区别" tabindex="-1">03-HTTP和HTTPS的区别 <a class="header-anchor" href="#_03-http和https的区别" aria-hidden="true">#</a></h2><ol><li>概述 <ul><li>HTTP是无状态的超文本传输协议，连接简单，信息是明文传输，端口为80</li><li>HTTPS是由http+ssl协议构建的可进行加密传输、身份认证的安全性网络协议，端口是443</li><li>HTTPS由于需要加密，所以性能方面不如HTTP</li></ul></li><li>HTTP <ul><li>无状态：HTTP协议无法根据之前的状态进行本次的请求处理</li><li>无连接：无连接是指先支付每次连接只处理一个请求</li></ul></li><li>HTTPS <ul><li>通信流程： <ul><li>客户端通过URL访问服务器建立SSL连接</li><li>服务端收到客户端请求后，将网站支持的证书信息传送到客户端</li><li>浏览器建立会话密钥，将公钥加密</li><li>发送加密后的信息</li><li>服务端解密</li></ul></li></ul></li></ol><h2 id="_04-地址栏输入url之后" tabindex="-1">04-地址栏输入URL之后 <a class="header-anchor" href="#_04-地址栏输入url之后" aria-hidden="true">#</a></h2><ol><li>对url进行DNS域名解析，得到对应的IP地址</li><li>根据这个IP，找到对应的服务器，发起TCP的三次握手</li><li>建立TCP连接后，发起HTTP请求</li><li>服务器响应HTTP请求，浏览器的大宋html代码</li><li>浏览器解析HTML代码，请求代码中的资源（js、css、img）</li><li>服务器响应对应的资源</li><li>响应数据完毕，四次挥手，关闭TCP连接</li><li>浏览器对页面进行渲染呈现给用户</li></ol><h2 id="_05-get和post的区别" tabindex="-1">05-GET和POST的区别 <a class="header-anchor" href="#_05-get和post的区别" aria-hidden="true">#</a></h2><ol><li>传输方式上：GET通过URL传输数据，POST通过请求体传输</li><li>数据安全上：GET数据暴露在URL上，可以通过浏览历史记录，缓存查到数据信息；POST数据因为在请求体中，所以具有一定的安全性</li><li>数据类型上：GET只接受ASCLL字符，POST没有限制</li><li>GET在浏览器回退是无害的，POST可以会再次提交请求</li><li>GET请求在URL中传送的参数是有长度限制的，POST没有</li><li>GET请求只能进行URL编码，而POST支持多种编码方式</li></ol><h2 id="_06-http常见的请求头" tabindex="-1">06-HTTP常见的请求头 <a class="header-anchor" href="#_06-http常见的请求头" aria-hidden="true">#</a></h2><ol><li>Accept：能够接收的回应内容类型（Accept: text/plain）</li><li>Accept-Charset：能够接收的字符集（Accept-Charset: utf-8）</li><li>Authoriation：用于超文本传输协议的认证的认证信息</li><li>Content-Type：请求体的多媒体类型（Content-Type: application/x-www-form-urlencoded）</li></ol><h2 id="_07-tcp三次握手和四次挥手" tabindex="-1">07-TCP三次握手和四次挥手 <a class="header-anchor" href="#_07-tcp三次握手和四次挥手" aria-hidden="true">#</a></h2><ol><li>三次握手 <ul><li>三次握手是为了确认对方的接收与发送能力是否正常 <ul><li>第一次握手：客户端给服务器发送一个SYN报文</li><li>第二次握手：服务器收到SYN报文后，会应答一个SYN+ACK报文</li><li>第三次握手：客户端收到SYN+ACK报文后，会回应一个ACK报文。服务器收到ACK报文后，三次握手建立完成</li></ul></li></ul></li><li>四次挥手 <ul><li>四次挥手是为了断开连接后资源正常释放，双方都可以主动断开连接</li><li>由于TCP连接是全双工的，因此每个方向都必须单独关闭 <ul><li>第一次挥手：客户端发送一个FIN报文，报文中会指定一个序列号，用来关闭客户端到服务端的连接</li><li>第二次挥手：服务端收到这个FIN，返回一个ACK，确认序号为收到的序号+1</li><li>第三次挥手：服务端关闭客户端的连接，发送一个FIN报文给客户端</li><li>第四次挥手：客户端返回ACK报文确认，并将确认序号设置为收到序号+1</li></ul></li></ul></li></ol><h2 id="_08-websocket" tabindex="-1">08-WebSocket <a class="header-anchor" href="#_08-websocket" aria-hidden="true">#</a></h2><ol><li>概述 <ul><li>WebSocket是HTML5下一种新的双向通信协议。它实现了客户端和服务器全双工通信，能更好的节省服务器资源并达到实时通信的目的</li><li>WebSocket需要像TCP一样，先建立连接，连接成功后才能相互通信</li><li>浏览器和服务器只需要做一个握手的动作，在建立连接之后，双方可以在任意时刻，相互推送信息</li></ul></li><li>WebSocket和HTTP的区别 <ol><li>相同点 <ul><li>都是基于TCP的，都是可靠性传输协议</li><li>都是应用层协议</li></ul></li><li>不同点 <ul><li>WebSocket是双向通信协议，可以双向发送或接收消息；HTTP是单向的</li><li>WebSocket是需要浏览器和服务器握手进行建立连接的，HTTP是浏览器发起向服务器的连接</li></ul></li></ol></li><li>应用场景 <ol><li>即时通讯（QQ、微信、客服）</li><li>弹幕</li><li>协同编辑</li><li>可视化大屏实时更新</li></ol></li></ol><h2 id="_09-cdn" tabindex="-1">09-CDN <a class="header-anchor" href="#_09-cdn" aria-hidden="true">#</a></h2><ol><li>概述 <ul><li>CDN：通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度</li><li>简而言之，CDN就是根据用户位置分配最近的资源</li></ul></li><li>CDN加速原理 <ul><li>当用户输入URL之后，经过本地DNS系统解析，DNS系统会将域名的解析权交给cdn专用DNS服务器</li><li>CDN的DNS服务器将CDN的全局负载均衡设备ip地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起访问请求</li><li>CDN全局负载均衡设备会根据用户ip，以及请求的URL，选择一台用户所属区域的区域负载均衡设备</li><li>区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求。若这台缓存服务器中没有用户所需内容，则向它的上一级缓存服务器发起请求，知道追朔到网站的源服务器将内容返回给用户</li></ul></li></ol><h2 id="_10-tcp和udp" tabindex="-1">10-TCP和UDP <a class="header-anchor" href="#_10-tcp和udp" aria-hidden="true">#</a></h2><ol><li>区别 <ul><li>TCP是面向连接的，可靠性高；UDP是基于非连接的</li><li>由于TCP是连接的通信，需要有三次握手等连接过程，会有延迟，实时性较差；UDP没有建立连接的过程，实时性较强，也稍安全</li><li>每条TCP连接只能是点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信</li></ul></li><li>应用场景 <ul><li>对实时性要求高和高速传输的场合下使用UDP；</li><li>需要传输大量数据且对可靠性要求高的情况下使用TCP;</li></ul></li></ol>`,21),t=[e];function p(o,r,c,D,h,u){return i(),s("div",null,t)}const d=l(n,[["render",p]]);export{y as __pageData,d as default};
