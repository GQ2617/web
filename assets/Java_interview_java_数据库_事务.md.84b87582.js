import{_ as t,c as e,o as l,d}from"./app.c282a12f.js";const c=JSON.parse('{"title":"事务","description":"","frontmatter":{},"headers":[{"level":2,"title":"01-说一说你对数据库事务的了解","slug":"_01-说一说你对数据库事务的了解","link":"#_01-说一说你对数据库事务的了解","children":[]},{"level":2,"title":"02-事务有哪几种类型，它们之间有什么区别？","slug":"_02-事务有哪几种类型-它们之间有什么区别","link":"#_02-事务有哪几种类型-它们之间有什么区别","children":[]},{"level":2,"title":"03-谈谈MySQL的事务隔离级别","slug":"_03-谈谈mysql的事务隔离级别","link":"#_03-谈谈mysql的事务隔离级别","children":[]},{"level":2,"title":"04-MySQL的事务隔离级别是怎么实现的？","slug":"_04-mysql的事务隔离级别是怎么实现的","link":"#_04-mysql的事务隔离级别是怎么实现的","children":[]},{"level":2,"title":"05-事务可以嵌套吗？","slug":"_05-事务可以嵌套吗","link":"#_05-事务可以嵌套吗","children":[]},{"level":2,"title":"06-如何实现可重复读？","slug":"_06-如何实现可重复读","link":"#_06-如何实现可重复读","children":[]},{"level":2,"title":"07-如何解决幻读问题？","slug":"_07-如何解决幻读问题","link":"#_07-如何解决幻读问题","children":[]},{"level":2,"title":"08-MySQL事务如何回滚？","slug":"_08-mysql事务如何回滚","link":"#_08-mysql事务如何回滚","children":[]}],"relativePath":"Java/interview_java/数据库/事务.md"}'),i={name:"Java/interview_java/数据库/事务.md"},a=d('<h1 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-hidden="true">#</a></h1><h2 id="_01-说一说你对数据库事务的了解" tabindex="-1">01-说一说你对数据库事务的了解 <a class="header-anchor" href="#_01-说一说你对数据库事务的了解" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>事务可由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。在事务中的操作，要么都执行修改，要么都不执行，这就是事务的目的，也是事务模型区别于文件系统的重要特征之一。</p><p>事务需遵循ACID四个特性：</p><ul><li>A（atomicity），原子性。原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，整个事务的执行才算成功。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</li><li>C（consistency），一致性。一致性指事务将数据库从一种状态转变为另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li><li>I（isolation），隔离性。事务的隔离性要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，这通常使用锁来实现。</li><li>D（durability） ，持久性。事务一旦提交，其结果就是永久性的，即使发生宕机等故障，数据库也能将数据恢复。持久性保证的是事务系统的高可靠性，而不是高可用性。</li></ul><p>事务可以分为以下几种类型：</p><ul><li>扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。</li><li>带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。</li><li>链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。</li><li>嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。</li><li>分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。</li></ul><h2 id="_02-事务有哪几种类型-它们之间有什么区别" tabindex="-1">02-事务有哪几种类型，它们之间有什么区别？ <a class="header-anchor" href="#_02-事务有哪几种类型-它们之间有什么区别" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>事务可以分为以下几种类型：</p><ul><li>扁平事务：是事务类型中最简单的一种，而在实际生产环境中，这可能是使用最为频繁的事务。在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。处于之间的操作是原子的，要么都执行，要么都回滚。</li><li>带有保存点的扁平事务：除了支持扁平事务支持的操作外，允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点（savepoint）用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。</li><li>链事务：可视为保存点模式的一个变种。链事务的思想是：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。</li><li>嵌套事务：是一个层次结构框架。有一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。</li><li>分布式事务：通常是一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效。</li></ul><h2 id="_03-谈谈mysql的事务隔离级别" tabindex="-1">03-谈谈MySQL的事务隔离级别 <a class="header-anchor" href="#_03-谈谈mysql的事务隔离级别" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>SQL 标准定义了四种隔离级别，这四种隔离级别分别是：</p><ul><li>读未提交（READ UNCOMMITTED）；</li><li>读提交 （READ COMMITTED）；</li><li>可重复读 （REPEATABLE READ）；</li><li>串行化 （SERIALIZABLE）。</li></ul><p>事务隔离是为了解决脏读、不可重复读、幻读问题，下表展示了 4 种隔离级别对这三个问题的解决程度：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>READ COMMITTED</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>REPEATABLE READ</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>SERIALIZABLE</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>上述4种隔离级别MySQL都支持，并且InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock的锁算法，因此避免了幻读的产生。所以，InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。</p><h2 id="_04-mysql的事务隔离级别是怎么实现的" tabindex="-1">04-MySQL的事务隔离级别是怎么实现的？ <a class="header-anchor" href="#_04-mysql的事务隔离级别是怎么实现的" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>InnoDB支持四种隔离级别，每种级别解决掉的问题如下表：</p><table><thead><tr><th></th><th>脏读</th><th>不可重复读幻读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>READ COMMITTED</td><td>N</td><td>Y</td><td>Y</td></tr><tr><td>REPEATABLE READ（默认）</td><td>N</td><td>N</td><td>N</td></tr><tr><td>SERIALIZABLE</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>这四种隔离级别的实现机制如下：</p><ol><li><p>READ UNCOMMITTED &amp; READ COMMITTED：</p><p>通过Record Lock算法实现了行锁，但READ UNCOMMITTED允许读取未提交数据，所以存在脏读问题。而READ COMMITTED允许读取提交数据，所以不存在脏读问题，但存在不可重复读问题。</p></li><li><p>REPEATABLE READ：</p><p>使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。</p></li><li><p>SERIALIZABLE：</p><p>对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。</p></li></ol><h2 id="_05-事务可以嵌套吗" tabindex="-1">05-事务可以嵌套吗？ <a class="header-anchor" href="#_05-事务可以嵌套吗" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>可以，因为嵌套事务也是众多事务分类中的一种，它是一个层次结构框架。有一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，它控制每一个局部的变换。</p><p>需要注意的是，MySQL数据库不支持嵌套事务。</p><h2 id="_06-如何实现可重复读" tabindex="-1">06-如何实现可重复读？ <a class="header-anchor" href="#_06-如何实现可重复读" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。</p><h2 id="_07-如何解决幻读问题" tabindex="-1">07-如何解决幻读问题？ <a class="header-anchor" href="#_07-如何解决幻读问题" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>MySQL的InnoDB引擎，在默认的REPEATABLE READ的隔离级别下，实现了可重复读，同时也解决了幻读问题。它使用Next-Key Lock算法实现了行锁，并且不允许读取已提交的数据，所以解决了不可重复读的问题。另外，该算法包含了间隙锁，会锁定一个范围，因此也解决了幻读的问题。</p><h2 id="_08-mysql事务如何回滚" tabindex="-1">08-MySQL事务如何回滚？ <a class="header-anchor" href="#_08-mysql事务如何回滚" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>在MySQL默认的配置下，事务都是自动提交和回滚的。当显示地开启一个事务时，可以使用ROLLBACK语句进行回滚。该语句有两种用法：</p><ul><li>ROLLBACK：要使用这个语句的最简形式，只需发出ROLLBACK。同样地，也可以写为ROLLBACK WORK，但是二者几乎是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li><li>ROLLBACK TO [SAVEPOINT] identifier ：这个语句与SAVEPOINT命令一起使用。可以把事务回滚到标记点，而不回滚在此标记点之前的任何工作。</li></ul>',39),r=[a];function n(h,s,o,p,E,_){return l(),e("div",null,r)}const L=t(i,[["render",n]]);export{c as __pageData,L as default};
