import{_ as a,c as e,o as h,d as s}from"./app.c282a12f.js";const b=JSON.parse('{"title":"哈希","description":"","frontmatter":{},"headers":[{"level":2,"title":"01-请谈一谈，hashCode() 和equals() 方法的重要性体现在什么地方？","slug":"_01-请谈一谈-hashcode-和equals-方法的重要性体现在什么地方","link":"#_01-请谈一谈-hashcode-和equals-方法的重要性体现在什么地方","children":[]},{"level":2,"title":"02-请说一说，Java中的HashMap的工作原理是什么？","slug":"_02-请说一说-java中的hashmap的工作原理是什么","link":"#_02-请说一说-java中的hashmap的工作原理是什么","children":[]},{"level":2,"title":"03-介绍一下，什么是hashmap?","slug":"_03-介绍一下-什么是hashmap","link":"#_03-介绍一下-什么是hashmap","children":[]},{"level":2,"title":"04-讲一讲，如何构造一致性哈希算法。","slug":"_04-讲一讲-如何构造一致性哈希算法。","link":"#_04-讲一讲-如何构造一致性哈希算法。","children":[]},{"level":2,"title":"05-请问，Object作为HashMap的key的话，对Object有什么要求吗？","slug":"_05-请问-object作为hashmap的key的话-对object有什么要求吗","link":"#_05-请问-object作为hashmap的key的话-对object有什么要求吗","children":[]},{"level":2,"title":"06-请问 HashSet 存的数是有序的吗？","slug":"_06-请问-hashset-存的数是有序的吗","link":"#_06-请问-hashset-存的数是有序的吗","children":[]}],"relativePath":"Computer/数据结构及算法/哈希.md"}'),r={name:"Computer/数据结构及算法/哈希.md"},t=s('<h1 id="哈希" tabindex="-1">哈希 <a class="header-anchor" href="#哈希" aria-hidden="true">#</a></h1><h2 id="_01-请谈一谈-hashcode-和equals-方法的重要性体现在什么地方" tabindex="-1">01-请谈一谈，hashCode() 和equals() 方法的重要性体现在什么地方？ <a class="header-anchor" href="#_01-请谈一谈-hashcode-和equals-方法的重要性体现在什么地方" aria-hidden="true">#</a></h2><p>考察点：JAVA哈希表</p><h4 id="参考回答" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答" aria-hidden="true">#</a></h4><p>Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。</p><h2 id="_02-请说一说-java中的hashmap的工作原理是什么" tabindex="-1">02-请说一说，Java中的HashMap的工作原理是什么？ <a class="header-anchor" href="#_02-请说一说-java中的hashmap的工作原理是什么" aria-hidden="true">#</a></h2><p>考察点：JAVA哈希表</p><h4 id="参考回答-1" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答-1" aria-hidden="true">#</a></h4><p>HashMap是以键值对的形式存储元素的，需要一个哈希函数，使用hashcode和eaquels方法，从集合中添加和检索元素，调用put方法时，会计算key 的哈希值，然后把键值对存在集合中合适的索引上，如果键key已经存在，value会被更新为新值。另外HashMap的初始容量是16，在jdk1.7的时候底层是基于数组和链表实现的，插入方式是头插法。jdk1.8的时候底层是基于数组和链表/红黑树实现的，插入方式为尾插法。</p><h2 id="_03-介绍一下-什么是hashmap" tabindex="-1">03-介绍一下，什么是hashmap? <a class="header-anchor" href="#_03-介绍一下-什么是hashmap" aria-hidden="true">#</a></h2><p>考察点：哈希表</p><h4 id="参考回答-2" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答-2" aria-hidden="true">#</a></h4><ul><li>HashMap 是一个散列表，它存储的内容是键值对(key-value)。</li><li>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，所以它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</li><li>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “负载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。负载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</li><li>HashMap在扩容的时候是2的n次幂。</li></ul><h2 id="_04-讲一讲-如何构造一致性哈希算法。" tabindex="-1">04-讲一讲，如何构造一致性哈希算法。 <a class="header-anchor" href="#_04-讲一讲-如何构造一致性哈希算法。" aria-hidden="true">#</a></h2><p>考察点：哈希算法</p><h4 id="参考回答-3" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答-3" aria-hidden="true">#</a></h4><p>先构造一个长度为2^32的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 2^32-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 2^32-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。</p><p>这种算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。</p><h2 id="_05-请问-object作为hashmap的key的话-对object有什么要求吗" tabindex="-1">05-请问，Object作为HashMap的key的话，对Object有什么要求吗？ <a class="header-anchor" href="#_05-请问-object作为hashmap的key的话-对object有什么要求吗" aria-hidden="true">#</a></h2><p>考察点：哈希表</p><h4 id="参考回答-4" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答-4" aria-hidden="true">#</a></h4><p>要求Object中hashcode不能变。</p><h2 id="_06-请问-hashset-存的数是有序的吗" tabindex="-1">06-请问 HashSet 存的数是有序的吗？ <a class="header-anchor" href="#_06-请问-hashset-存的数是有序的吗" aria-hidden="true">#</a></h2><p>考察点：哈希</p><h4 id="参考回答-5" tabindex="-1">参考回答： <a class="header-anchor" href="#参考回答-5" aria-hidden="true">#</a></h4><p>HashSet是无序的。</p>',26),d=[t];function i(l,n,c,p,o,_){return h(),e("div",null,d)}const H=a(r,[["render",i]]);export{b as __pageData,H as default};
