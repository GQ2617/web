import{_ as e,c as p,o as a,d as l}from"./app.c282a12f.js";const E=JSON.parse('{"title":"SQL","description":"","frontmatter":{},"headers":[{"level":2,"title":"01-介绍一下SQL中的聚合函数","slug":"_01-介绍一下sql中的聚合函数","link":"#_01-介绍一下sql中的聚合函数","children":[]},{"level":2,"title":"02-表跟表是怎么关联的？","slug":"_02-表跟表是怎么关联的","link":"#_02-表跟表是怎么关联的","children":[]},{"level":2,"title":"03-说一说你对外连接的了解","slug":"_03-说一说你对外连接的了解","link":"#_03-说一说你对外连接的了解","children":[]},{"level":2,"title":"04-说一说数据库的左连接和右连接","slug":"_04-说一说数据库的左连接和右连接","link":"#_04-说一说数据库的左连接和右连接","children":[]},{"level":2,"title":"05-WHERE和HAVING有什么区别？","slug":"_05-where和having有什么区别","link":"#_05-where和having有什么区别","children":[]}],"relativePath":"Java/interview_java/数据库/SQL.md"}'),i={name:"Java/interview_java/数据库/SQL.md"},r=l('<h1 id="sql" tabindex="-1">SQL <a class="header-anchor" href="#sql" aria-hidden="true">#</a></h1><h2 id="_01-介绍一下sql中的聚合函数" tabindex="-1">01-介绍一下SQL中的聚合函数 <a class="header-anchor" href="#_01-介绍一下sql中的聚合函数" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>常用的聚合函数有COUNT()、AVG()、SUM()、MAX()、MIN()，下面以MySQL为例，说明这些函数的作用。</p><p>COUNT()函数：</p><p>COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回列中包含的数据行数，它有两种用法：</p><ul><li>COUNT(*)计算表中总的行数，不管某列是否有数值或者为空值。</li><li>COUNT(字段名)计算指定列下总的行数，计算时将忽略空值的行。</li></ul><p>COUNT()函数可以与GROUP BY一起使用来计算每个分组的总和。</p><p>AVG()函数()：</p><p>AVG()函数通过计算返回的行数和每一行数据的和，求得指定列数据的平均值。</p><p>AVG()函数可以与GROUP BY一起使用，来计算每个分组的平均值。</p><p>SUM()函数：</p><p>SUM()是一个求总和的函数，返回指定列值的总和。</p><p>SUM()可以与GROUP BY一起使用，来计算每个分组的总和。</p><p>MAX()函数：</p><p>MAX()返回指定列中的最大值。</p><p>MAX()也可以和GROUP BY关键字一起使用，求每个分组中的最大值。</p><p>MAX()函数不仅适用于查找数值类型，也可应用于字符类型。</p><p>MIN()函数：</p><p>MIN()返回查询列中的最小值。</p><p>MIN()也可以和GROUP BY关键字一起使用，求出每个分组中的最小值。</p><p>MIN()函数与MAX()函数类似，不仅适用于查找数值类型，也可应用于字符类型。</p><h2 id="_02-表跟表是怎么关联的" tabindex="-1">02-表跟表是怎么关联的？ <a class="header-anchor" href="#_02-表跟表是怎么关联的" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>表与表之间常用的关联方式有两种：内连接、外连接，下面以MySQL为例来说明这两种连接方式。</p><p>内连接：</p><p>内连接通过INNER JOIN来实现，它将返回两张表中满足连接条件的数据，不满足条件的数据不会查询出来。</p><p>外连接：</p><p>外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据。外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）。</p><ul><li>左外连接：可以简称为左连接（LEFT JOIN），它会返回左表中的所有记录和右表中满足连接条件的记录。</li><li>右外连接：可以简称为右连接（RIGHT JOIN），它会返回右表中的所有记录和左表中满足连接条件的记录。</li></ul><p>除此之外，还有一种常见的连接方式：等值连接。这种连接是通过WHERE子句中的条件，将两张表连接在一起，它的实际效果等同于内连接。出于语义清晰的考虑，一般更建议使用内连接，而不是等值连接。</p><p>以上是从语法上来说明表与表之间关联的实现方式，而从表的关系上来说，比较常见的关联关系有：一对多关联、多对多关联、自关联。</p><ul><li>一对多关联：这种关联形式最为常见，一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。</li><li>多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。</li><li>自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。</li></ul><h2 id="_03-说一说你对外连接的了解" tabindex="-1">03-说一说你对外连接的了解 <a class="header-anchor" href="#_03-说一说你对外连接的了解" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据。常见的外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）。</p><ul><li>左外连接：可以简称为左连接（LEFT JOIN），它会返回左表中的所有记录和右表中满足连接条件的记录。</li><li>右外连接：可以简称为右连接（RIGHT JOIN），它会返回右表中的所有记录和左表中满足连接条件的记录。</li></ul><p>实际上，外连接还有一种形式：完全外连接（FULL OUTER JOIN），但MySQL不支持这种形式。</p><h2 id="_04-说一说数据库的左连接和右连接" tabindex="-1">04-说一说数据库的左连接和右连接 <a class="header-anchor" href="#_04-说一说数据库的左连接和右连接" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>外连接通过OUTER JOIN来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据。常见的外连接有两种形式：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）。</p><ul><li>左外连接：可以简称为左连接（LEFT JOIN），它会返回左表中的所有记录和右表中满足连接条件的记录。</li><li>右外连接：可以简称为右连接（RIGHT JOIN），它会返回右表中的所有记录和左表中满足连接条件的记录。</li></ul><h2 id="_05-where和having有什么区别" tabindex="-1">05-WHERE和HAVING有什么区别？ <a class="header-anchor" href="#_05-where和having有什么区别" aria-hidden="true">#</a></h2><p><strong>参考答案</strong></p><p>WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。</p><p>HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。</p><p>从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。</p>',47),t=[r];function n(h,s,_,d,N,O){return a(),p("div",null,t)}const I=e(i,[["render",n]]);export{E as __pageData,I as default};
